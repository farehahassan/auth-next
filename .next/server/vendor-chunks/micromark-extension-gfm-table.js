"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micromark-extension-gfm-table";
exports.ids = ["vendor-chunks/micromark-extension-gfm-table"];
exports.modules = {

/***/ "(rsc)/./node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js":
/*!************************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditMap: () => (/* binding */ EditMap)\n/* harmony export */ });\n/**\n * @typedef {import('micromark-util-types').Event} Event\n */ // Port of `edit_map.rs` from `markdown-rs`.\n// This should move to `markdown-js` later.\n// Deal with several changes in events, batching them together.\n//\n// Preferably, changes should be kept to a minimum.\n// Sometimes, it’s needed to change the list of events, because parsing can be\n// messy, and it helps to expose a cleaner interface of events to the compiler\n// and other users.\n// It can also help to merge many adjacent similar events.\n// And, in other cases, it’s needed to parse subcontent: pass some events\n// through another tokenizer and inject the result.\n/**\n * @typedef {[number, number, Array<Event>]} Change\n * @typedef {[number, number, number]} Jump\n */ /**\n * Tracks a bunch of edits.\n */ class EditMap {\n    /**\n   * Create a new edit map.\n   */ constructor(){\n        /**\n     * Record of changes.\n     *\n     * @type {Array<Change>}\n     */ this.map = [];\n    }\n    /**\n   * Create an edit: a remove and/or add at a certain place.\n   *\n   * @param {number} index\n   * @param {number} remove\n   * @param {Array<Event>} add\n   * @returns {void}\n   */ add(index, remove, add) {\n        addImpl(this, index, remove, add);\n    }\n    // To do: not used here.\n    // /**\n    //  * Create an edit: but insert `add` before existing additions.\n    //  *\n    //  * @param {number} index\n    //  * @param {number} remove\n    //  * @param {Array<Event>} add\n    //  * @returns {void}\n    //  */\n    // addBefore(index, remove, add) {\n    //   addImpl(this, index, remove, add, true)\n    // }\n    /**\n   * Done, change the events.\n   *\n   * @param {Array<Event>} events\n   * @returns {void}\n   */ consume(events) {\n        this.map.sort((a, b)=>a[0] - b[0]);\n        /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */ if (this.map.length === 0) {\n            return;\n        }\n        // To do: if links are added in events, like they are in `markdown-rs`,\n        // this is needed.\n        // // Calculate jumps: where items in the current list move to.\n        // /** @type {Array<Jump>} */\n        // const jumps = []\n        // let index = 0\n        // let addAcc = 0\n        // let removeAcc = 0\n        // while (index < this.map.length) {\n        //   const [at, remove, add] = this.map[index]\n        //   removeAcc += remove\n        //   addAcc += add.length\n        //   jumps.push([at, removeAcc, addAcc])\n        //   index += 1\n        // }\n        //\n        // . shiftLinks(events, jumps)\n        let index = this.map.length;\n        /** @type {Array<Array<Event>>} */ const vecs = [];\n        while(index > 0){\n            index -= 1;\n            vecs.push(events.slice(this.map[index][0] + this.map[index][1]));\n            // eslint-disable-next-line unicorn/no-array-push-push\n            vecs.push(this.map[index][2]);\n            // Truncate rest.\n            events.length = this.map[index][0];\n        }\n        vecs.push([\n            ...events\n        ]);\n        events.length = 0;\n        let slice = vecs.pop();\n        while(slice){\n            events.push(...slice);\n            slice = vecs.pop();\n        }\n        // Truncate everything.\n        this.map.length = 0;\n    }\n}\n/**\n * Create an edit.\n *\n * @param {EditMap} editMap\n * @param {number} at\n * @param {number} remove\n * @param {Array<Event>} add\n * @returns {void}\n */ function addImpl(editMap, at, remove, add) {\n    let index = 0;\n    /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */ if (remove === 0 && add.length === 0) {\n        return;\n    }\n    while(index < editMap.map.length){\n        if (editMap.map[index][0] === at) {\n            editMap.map[index][1] += remove;\n            // To do: before not used.\n            // if (before) {\n            //   add.push(...editMap.map[index][2])\n            //   editMap.map[index][2] = add\n            // } else {\n            editMap.map[index][2].push(...add);\n            // }\n            return;\n        }\n        index += 1;\n    }\n    editMap.map.push([\n        at,\n        remove,\n        add\n    ]);\n} // /**\n //  * Shift `previous` and `next` links according to `jumps`.\n //  *\n //  * This fixes links in case there are events removed or added between them.\n //  *\n //  * @param {Array<Event>} events\n //  * @param {Array<Jump>} jumps\n //  */\n // function shiftLinks(events, jumps) {\n //   let jumpIndex = 0\n //   let index = 0\n //   let add = 0\n //   let rm = 0\n //   while (index < events.length) {\n //     const rmCurr = rm\n //     while (jumpIndex < jumps.length && jumps[jumpIndex][0] <= index) {\n //       add = jumps[jumpIndex][2]\n //       rm = jumps[jumpIndex][1]\n //       jumpIndex += 1\n //     }\n //     // Ignore items that will be removed.\n //     if (rm > rmCurr) {\n //       index += rm - rmCurr\n //     } else {\n //       console.log('to do: links?', add, rmCurr)\n //       // ?\n //       // if let Some(link) = &events[index].link {\n //       //     if let Some(next) = link.next {\n //       //         events[next].link.as_mut().unwrap().previous = Some(index + add - rm);\n //       //         while jumpIndex < jumps.len() && jumps[jumpIndex].0 <= next {\n //       //             add = jumps[jumpIndex].2;\n //       //             rm = jumps[jumpIndex].1;\n //       //             jumpIndex += 1;\n //       //         }\n //       //         events[index].link.as_mut().unwrap().next = Some(next + add - rm);\n //       //         index = next;\n //       //         continue;\n //       //     }\n //       // }\n //       index += 1\n //     }\n //   }\n // }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvZGV2L2xpYi9lZGl0LW1hcC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FFRCw0Q0FBNEM7QUFDNUMsMkNBQTJDO0FBRTNDLCtEQUErRDtBQUMvRCxFQUFFO0FBQ0YsbURBQW1EO0FBQ25ELDhFQUE4RTtBQUM5RSw4RUFBOEU7QUFDOUUsbUJBQW1CO0FBQ25CLDBEQUEwRDtBQUMxRCx5RUFBeUU7QUFDekUsbURBQW1EO0FBRW5EOzs7Q0FHQyxHQUVEOztDQUVDLEdBQ00sTUFBTUE7SUFDWDs7R0FFQyxHQUNEQyxhQUFjO1FBQ1o7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ0MsR0FBRyxHQUFHLEVBQUU7SUFDZjtJQUVBOzs7Ozs7O0dBT0MsR0FDREMsSUFBSUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVGLEdBQUcsRUFBRTtRQUN0QkcsUUFBUSxJQUFJLEVBQUVGLE9BQU9DLFFBQVFGO0lBQy9CO0lBRUEsd0JBQXdCO0lBQ3hCLE1BQU07SUFDTixpRUFBaUU7SUFDakUsS0FBSztJQUNMLDJCQUEyQjtJQUMzQiw0QkFBNEI7SUFDNUIsK0JBQStCO0lBQy9CLHFCQUFxQjtJQUNyQixNQUFNO0lBQ04sa0NBQWtDO0lBQ2xDLDRDQUE0QztJQUM1QyxJQUFJO0lBRUo7Ozs7O0dBS0MsR0FDREksUUFBUUMsTUFBTSxFQUFFO1FBQ2QsSUFBSSxDQUFDTixHQUFHLENBQUNPLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxDQUFDLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRTtRQUVuQyxtRkFBbUYsR0FDbkYsSUFBSSxJQUFJLENBQUNULEdBQUcsQ0FBQ1UsTUFBTSxLQUFLLEdBQUc7WUFDekI7UUFDRjtRQUVBLHVFQUF1RTtRQUN2RSxrQkFBa0I7UUFDbEIsK0RBQStEO1FBQy9ELDZCQUE2QjtRQUM3QixtQkFBbUI7UUFDbkIsZ0JBQWdCO1FBQ2hCLGlCQUFpQjtR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dWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWJsZS9kZXYvbGliL2VkaXQtbWFwLmpzPzA0ZTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV2ZW50fSBFdmVudFxuICovXG5cbi8vIFBvcnQgb2YgYGVkaXRfbWFwLnJzYCBmcm9tIGBtYXJrZG93bi1yc2AuXG4vLyBUaGlzIHNob3VsZCBtb3ZlIHRvIGBtYXJrZG93bi1qc2AgbGF0ZXIuXG5cbi8vIERlYWwgd2l0aCBzZXZlcmFsIGNoYW5nZXMgaW4gZXZlbnRzLCBiYXRjaGluZyB0aGVtIHRvZ2V0aGVyLlxuLy9cbi8vIFByZWZlcmFibHksIGNoYW5nZXMgc2hvdWxkIGJlIGtlcHQgdG8gYSBtaW5pbXVtLlxuLy8gU29tZXRpbWVzLCBpdOKAmXMgbmVlZGVkIHRvIGNoYW5nZSB0aGUgbGlzdCBvZiBldmVudHMsIGJlY2F1c2UgcGFyc2luZyBjYW4gYmVcbi8vIG1lc3N5LCBhbmQgaXQgaGVscHMgdG8gZXhwb3NlIGEgY2xlYW5lciBpbnRlcmZhY2Ugb2YgZXZlbnRzIHRvIHRoZSBjb21waWxlclxuLy8gYW5kIG90aGVyIHVzZXJzLlxuLy8gSXQgY2FuIGFsc28gaGVscCB0byBtZXJnZSBtYW55IGFkamFjZW50IHNpbWlsYXIgZXZlbnRzLlxuLy8gQW5kLCBpbiBvdGhlciBjYXNlcywgaXTigJlzIG5lZWRlZCB0byBwYXJzZSBzdWJjb250ZW50OiBwYXNzIHNvbWUgZXZlbnRzXG4vLyB0aHJvdWdoIGFub3RoZXIgdG9rZW5pemVyIGFuZCBpbmplY3QgdGhlIHJlc3VsdC5cblxuLyoqXG4gKiBAdHlwZWRlZiB7W251bWJlciwgbnVtYmVyLCBBcnJheTxFdmVudD5dfSBDaGFuZ2VcbiAqIEB0eXBlZGVmIHtbbnVtYmVyLCBudW1iZXIsIG51bWJlcl19IEp1bXBcbiAqL1xuXG4vKipcbiAqIFRyYWNrcyBhIGJ1bmNoIG9mIGVkaXRzLlxuICovXG5leHBvcnQgY2xhc3MgRWRpdE1hcCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZWRpdCBtYXAuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBSZWNvcmQgb2YgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTxDaGFuZ2U+fVxuICAgICAqL1xuICAgIHRoaXMubWFwID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZWRpdDogYSByZW1vdmUgYW5kL29yIGFkZCBhdCBhIGNlcnRhaW4gcGxhY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVtb3ZlXG4gICAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBhZGRcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBhZGQoaW5kZXgsIHJlbW92ZSwgYWRkKSB7XG4gICAgYWRkSW1wbCh0aGlzLCBpbmRleCwgcmVtb3ZlLCBhZGQpXG4gIH1cblxuICAvLyBUbyBkbzogbm90IHVzZWQgaGVyZS5cbiAgLy8gLyoqXG4gIC8vICAqIENyZWF0ZSBhbiBlZGl0OiBidXQgaW5zZXJ0IGBhZGRgIGJlZm9yZSBleGlzdGluZyBhZGRpdGlvbnMuXG4gIC8vICAqXG4gIC8vICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAvLyAgKiBAcGFyYW0ge251bWJlcn0gcmVtb3ZlXG4gIC8vICAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBhZGRcbiAgLy8gICogQHJldHVybnMge3ZvaWR9XG4gIC8vICAqL1xuICAvLyBhZGRCZWZvcmUoaW5kZXgsIHJlbW92ZSwgYWRkKSB7XG4gIC8vICAgYWRkSW1wbCh0aGlzLCBpbmRleCwgcmVtb3ZlLCBhZGQsIHRydWUpXG4gIC8vIH1cblxuICAvKipcbiAgICogRG9uZSwgY2hhbmdlIHRoZSBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBldmVudHNcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjb25zdW1lKGV2ZW50cykge1xuICAgIHRoaXMubWFwLnNvcnQoKGEsIGIpID0+IGFbMF0gLSBiWzBdKVxuXG4gICAgLyogYzggaWdub3JlIG5leHQgMyAtLSBgcmVzb2x2ZWAgaXMgbmV2ZXIgY2FsbGVkIHdpdGhvdXQgdGFibGVzLCBzbyB3aXRob3V0IGVkaXRzLiAqL1xuICAgIGlmICh0aGlzLm1hcC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFRvIGRvOiBpZiBsaW5rcyBhcmUgYWRkZWQgaW4gZXZlbnRzLCBsaWtlIHRoZXkgYXJlIGluIGBtYXJrZG93bi1yc2AsXG4gICAgLy8gdGhpcyBpcyBuZWVkZWQuXG4gICAgLy8gLy8gQ2FsY3VsYXRlIGp1bXBzOiB3aGVyZSBpdGVtcyBpbiB0aGUgY3VycmVudCBsaXN0IG1vdmUgdG8uXG4gICAgLy8gLyoqIEB0eXBlIHtBcnJheTxKdW1wPn0gKi9cbiAgICAvLyBjb25zdCBqdW1wcyA9IFtdXG4gICAgLy8gbGV0IGluZGV4ID0gMFxuICAgIC8vIGxldCBhZGRBY2MgPSAwXG4gICAgLy8gbGV0IHJlbW92ZUFjYyA9IDBcbiAgICAvLyB3aGlsZSAoaW5kZXggPCB0aGlzLm1hcC5sZW5ndGgpIHtcbiAgICAvLyAgIGNvbnN0IFthdCwgcmVtb3ZlLCBhZGRdID0gdGhpcy5tYXBbaW5kZXhdXG4gICAgLy8gICByZW1vdmVBY2MgKz0gcmVtb3ZlXG4gICAgLy8gICBhZGRBY2MgKz0gYWRkLmxlbmd0aFxuICAgIC8vICAganVtcHMucHVzaChbYXQsIHJlbW92ZUFjYywgYWRkQWNjXSlcbiAgICAvLyAgIGluZGV4ICs9IDFcbiAgICAvLyB9XG4gICAgLy9cbiAgICAvLyAuIHNoaWZ0TGlua3MoZXZlbnRzLCBqdW1wcylcblxuICAgIGxldCBpbmRleCA9IHRoaXMubWFwLmxlbmd0aFxuICAgIC8qKiBAdHlwZSB7QXJyYXk8QXJyYXk8RXZlbnQ+Pn0gKi9cbiAgICBjb25zdCB2ZWNzID0gW11cbiAgICB3aGlsZSAoaW5kZXggPiAwKSB7XG4gICAgICBpbmRleCAtPSAxXG4gICAgICB2ZWNzLnB1c2goZXZlbnRzLnNsaWNlKHRoaXMubWFwW2luZGV4XVswXSArIHRoaXMubWFwW2luZGV4XVsxXSkpXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby1hcnJheS1wdXNoLXB1c2hcbiAgICAgIHZlY3MucHVzaCh0aGlzLm1hcFtpbmRleF1bMl0pXG5cbiAgICAgIC8vIFRydW5jYXRlIHJlc3QuXG4gICAgICBldmVudHMubGVuZ3RoID0gdGhpcy5tYXBbaW5kZXhdWzBdXG4gICAgfVxuXG4gICAgdmVjcy5wdXNoKFsuLi5ldmVudHNdKVxuICAgIGV2ZW50cy5sZW5ndGggPSAwXG5cbiAgICBsZXQgc2xpY2UgPSB2ZWNzLnBvcCgpXG5cbiAgICB3aGlsZSAoc2xpY2UpIHtcbiAgICAgIGV2ZW50cy5wdXNoKC4uLnNsaWNlKVxuICAgICAgc2xpY2UgPSB2ZWNzLnBvcCgpXG4gICAgfVxuXG4gICAgLy8gVHJ1bmNhdGUgZXZlcnl0aGluZy5cbiAgICB0aGlzLm1hcC5sZW5ndGggPSAwXG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZWRpdC5cbiAqXG4gKiBAcGFyYW0ge0VkaXRNYXB9IGVkaXRNYXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBhdFxuICogQHBhcmFtIHtudW1iZXJ9IHJlbW92ZVxuICogQHBhcmFtIHtBcnJheTxFdmVudD59IGFkZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGFkZEltcGwoZWRpdE1hcCwgYXQsIHJlbW92ZSwgYWRkKSB7XG4gIGxldCBpbmRleCA9IDBcblxuICAvKiBjOCBpZ25vcmUgbmV4dCAzIC0tIGByZXNvbHZlYCBpcyBuZXZlciBjYWxsZWQgd2l0aG91dCB0YWJsZXMsIHNvIHdpdGhvdXQgZWRpdHMuICovXG4gIGlmIChyZW1vdmUgPT09IDAgJiYgYWRkLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgd2hpbGUgKGluZGV4IDwgZWRpdE1hcC5tYXAubGVuZ3RoKSB7XG4gICAgaWYgKGVkaXRNYXAubWFwW2luZGV4XVswXSA9PT0gYXQpIHtcbiAgICAgIGVkaXRNYXAubWFwW2luZGV4XVsxXSArPSByZW1vdmVcblxuICAgICAgLy8gVG8gZG86IGJlZm9yZSBub3QgdXNlZC5cbiAgICAgIC8vIGlmIChiZWZvcmUpIHtcbiAgICAgIC8vICAgYWRkLnB1c2goLi4uZWRpdE1hcC5tYXBbaW5kZXhdWzJdKVxuICAgICAgLy8gICBlZGl0TWFwLm1hcFtpbmRleF1bMl0gPSBhZGRcbiAgICAgIC8vIH0gZWxzZSB7XG4gICAgICBlZGl0TWFwLm1hcFtpbmRleF1bMl0ucHVzaCguLi5hZGQpXG4gICAgICAvLyB9XG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGluZGV4ICs9IDFcbiAgfVxuXG4gIGVkaXRNYXAubWFwLnB1c2goW2F0LCByZW1vdmUsIGFkZF0pXG59XG5cbi8vIC8qKlxuLy8gICogU2hpZnQgYHByZXZpb3VzYCBhbmQgYG5leHRgIGxpbmtzIGFjY29yZGluZyB0byBganVtcHNgLlxuLy8gICpcbi8vICAqIFRoaXMgZml4ZXMgbGlua3MgaW4gY2FzZSB0aGVyZSBhcmUgZXZlbnRzIHJlbW92ZWQgb3IgYWRkZWQgYmV0d2VlbiB0aGVtLlxuLy8gICpcbi8vICAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBldmVudHNcbi8vICAqIEBwYXJhbSB7QXJyYXk8SnVtcD59IGp1bXBzXG4vLyAgKi9cbi8vIGZ1bmN0aW9uIHNoaWZ0TGlua3MoZXZlbnRzLCBqdW1wcykge1xuLy8gICBsZXQganVtcEluZGV4ID0gMFxuLy8gICBsZXQgaW5kZXggPSAwXG4vLyAgIGxldCBhZGQgPSAwXG4vLyAgIGxldCBybSA9IDBcblxuLy8gICB3aGlsZSAoaW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4vLyAgICAgY29uc3Qgcm1DdXJyID0gcm1cblxuLy8gICAgIHdoaWxlIChqdW1wSW5kZXggPCBqdW1wcy5sZW5ndGggJiYganVtcHNbanVtcEluZGV4XVswXSA8PSBpbmRleCkge1xuLy8gICAgICAgYWRkID0ganVtcHNbanVtcEluZGV4XVsyXVxuLy8gICAgICAgcm0gPSBqdW1wc1tqdW1wSW5kZXhdWzFdXG4vLyAgICAgICBqdW1wSW5kZXggKz0gMVxuLy8gICAgIH1cblxuLy8gICAgIC8vIElnbm9yZSBpdGVtcyB0aGF0IHdpbGwgYmUgcmVtb3ZlZC5cbi8vICAgICBpZiAocm0gPiBybUN1cnIpIHtcbi8vICAgICAgIGluZGV4ICs9IHJtIC0gcm1DdXJyXG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgIGNvbnNvbGUubG9nKCd0byBkbzogbGlua3M/JywgYWRkLCBybUN1cnIpXG4vLyAgICAgICAvLyA/XG4vLyAgICAgICAvLyBpZiBsZXQgU29tZShsaW5rKSA9ICZldmVudHNbaW5kZXhdLmxpbmsge1xuLy8gICAgICAgLy8gICAgIGlmIGxldCBTb21lKG5leHQpID0gbGluay5uZXh0IHtcbi8vICAgICAgIC8vICAgICAgICAgZXZlbnRzW25leHRdLmxpbmsuYXNfbXV0KCkudW53cmFwKCkucHJldmlvdXMgPSBTb21lKGluZGV4ICsgYWRkIC0gcm0pO1xuLy8gICAgICAgLy8gICAgICAgICB3aGlsZSBqdW1wSW5kZXggPCBqdW1wcy5sZW4oKSAmJiBqdW1wc1tqdW1wSW5kZXhdLjAgPD0gbmV4dCB7XG4vLyAgICAgICAvLyAgICAgICAgICAgICBhZGQgPSBqdW1wc1tqdW1wSW5kZXhdLjI7XG4vLyAgICAgICAvLyAgICAgICAgICAgICBybSA9IGp1bXBzW2p1bXBJbmRleF0uMTtcbi8vICAgICAgIC8vICAgICAgICAgICAgIGp1bXBJbmRleCArPSAxO1xuLy8gICAgICAgLy8gICAgICAgICB9XG4vLyAgICAgICAvLyAgICAgICAgIGV2ZW50c1tpbmRleF0ubGluay5hc19tdXQoKS51bndyYXAoKS5uZXh0ID0gU29tZShuZXh0ICsgYWRkIC0gcm0pO1xuLy8gICAgICAgLy8gICAgICAgICBpbmRleCA9IG5leHQ7XG4vLyAgICAgICAvLyAgICAgICAgIGNvbnRpbnVlO1xuLy8gICAgICAgLy8gICAgIH1cbi8vICAgICAgIC8vIH1cbi8vICAgICAgIGluZGV4ICs9IDFcbi8vICAgICB9XG4vLyAgIH1cbi8vIH1cbiJdLCJuYW1lcyI6WyJFZGl0TWFwIiwiY29uc3RydWN0b3IiLCJtYXAiLCJhZGQiLCJpbmRleCIsInJlbW92ZSIsImFkZEltcGwiLCJjb25zdW1lIiwiZXZlbnRzIiwic29ydCIsImEiLCJiIiwibGVuZ3RoIiwidmVjcyIsInB1c2giLCJzbGljZSIsInBvcCIsImVkaXRNYXAiLCJhdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/micromark-extension-gfm-table/dev/lib/html.js":
/*!********************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/dev/lib/html.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTableHtml: () => (/* binding */ gfmTableHtml)\n/* harmony export */ });\n/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uvu/assert */ \"(rsc)/./node_modules/uvu/assert/index.mjs\");\n/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */ /**\n * @typedef {import('./infer.js').Align} Align\n */ \nconst alignment = {\n    none: \"\",\n    left: ' align=\"left\"',\n    right: ' align=\"right\"',\n    center: ' align=\"center\"'\n};\n// To do: next major: expose functions.\n// To do: next major: use `infer` here, when all events are exposed.\n/**\n * Extension for `micromark` that can be passed in `htmlExtensions` to support\n * GFM tables when serializing to HTML.\n *\n * @type {HtmlExtension}\n */ const gfmTableHtml = {\n    enter: {\n        table (token) {\n            const tableAlign = token._align;\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, \"expected `_align`\");\n            this.lineEndingIfNeeded();\n            this.tag(\"<table>\");\n            this.setData(\"tableAlign\", tableAlign);\n        },\n        tableBody () {\n            this.tag(\"<tbody>\");\n        },\n        tableData () {\n            const tableAlign = this.getData(\"tableAlign\");\n            const tableColumn = this.getData(\"tableColumn\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, \"expected `tableAlign`\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === \"number\", \"expected `tableColumn`\");\n            const align = alignment[tableAlign[tableColumn]];\n            if (align === undefined) {\n                // Capture results to ignore them.\n                this.buffer();\n            } else {\n                this.lineEndingIfNeeded();\n                this.tag(\"<td\" + align + \">\");\n            }\n        },\n        tableHead () {\n            this.lineEndingIfNeeded();\n            this.tag(\"<thead>\");\n        },\n        tableHeader () {\n            const tableAlign = this.getData(\"tableAlign\");\n            const tableColumn = this.getData(\"tableColumn\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, \"expected `tableAlign`\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === \"number\", \"expected `tableColumn`\");\n            const align = alignment[tableAlign[tableColumn]];\n            this.lineEndingIfNeeded();\n            this.tag(\"<th\" + align + \">\");\n        },\n        tableRow () {\n            this.setData(\"tableColumn\", 0);\n            this.lineEndingIfNeeded();\n            this.tag(\"<tr>\");\n        }\n    },\n    exit: {\n        // Overwrite the default code text data handler to unescape escaped pipes when\n        // they are in tables.\n        codeTextData (token) {\n            let value = this.sliceSerialize(token);\n            if (this.getData(\"tableAlign\")) {\n                value = value.replace(/\\\\([\\\\|])/g, replace);\n            }\n            this.raw(this.encode(value));\n        },\n        table () {\n            this.setData(\"tableAlign\");\n            // Note: we don’t set `slurpAllLineEndings` anymore, in delimiter rows,\n            // but we do need to reset it to match a funky newline GH generates for\n            // list items combined with tables.\n            this.setData(\"slurpAllLineEndings\");\n            this.lineEndingIfNeeded();\n            this.tag(\"</table>\");\n        },\n        tableBody () {\n            this.lineEndingIfNeeded();\n            this.tag(\"</tbody>\");\n        },\n        tableData () {\n            const tableAlign = this.getData(\"tableAlign\");\n            const tableColumn = this.getData(\"tableColumn\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, \"expected `tableAlign`\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === \"number\", \"expected `tableColumn`\");\n            if (tableColumn in tableAlign) {\n                this.tag(\"</td>\");\n                this.setData(\"tableColumn\", tableColumn + 1);\n            } else {\n                // Stop capturing.\n                this.resume();\n            }\n        },\n        tableHead () {\n            this.lineEndingIfNeeded();\n            this.tag(\"</thead>\");\n        },\n        tableHeader () {\n            const tableColumn = this.getData(\"tableColumn\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === \"number\", \"expected `tableColumn`\");\n            this.tag(\"</th>\");\n            this.setData(\"tableColumn\", tableColumn + 1);\n        },\n        tableRow () {\n            const tableAlign = this.getData(\"tableAlign\");\n            let tableColumn = this.getData(\"tableColumn\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, \"expected `tableAlign`\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === \"number\", \"expected `tableColumn`\");\n            while(tableColumn < tableAlign.length){\n                this.lineEndingIfNeeded();\n                this.tag(\"<td\" + alignment[tableAlign[tableColumn]] + \"></td>\");\n                tableColumn++;\n            }\n            this.setData(\"tableColumn\", tableColumn);\n            this.lineEndingIfNeeded();\n            this.tag(\"</tr>\");\n        }\n    }\n};\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */ function replace($0, $1) {\n    // Pipes work, backslashes don’t (but can’t escape pipes).\n    return $1 === \"|\" ? $1 : $0;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvZGV2L2xpYi9odG1sLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0NBRUMsR0FFRDs7Q0FFQyxHQUVzQztBQUV2QyxNQUFNRSxZQUFZO0lBQ2hCQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTztJQUNQQyxRQUFRO0FBQ1Y7QUFFQSx1Q0FBdUM7QUFDdkMsb0VBQW9FO0FBRXBFOzs7OztDQUtDLEdBQ00sTUFBTUMsZUFBZTtJQUMxQkMsT0FBTztRQUNMQyxPQUFNQyxLQUFLO1lBQ1QsTUFBTUMsYUFBYUQsTUFBTUUsTUFBTTtZQUMvQlgsOENBQU1BLENBQUNVLFlBQVk7WUFDbkIsSUFBSSxDQUFDRSxrQkFBa0I7WUFDdkIsSUFBSSxDQUFDQyxHQUFHLENBQUM7WUFDVCxJQUFJLENBQUNDLE9BQU8sQ0FBQyxjQUFjSjtRQUM3QjtRQUNBSztZQUNFLElBQUksQ0FBQ0YsR0FBRyxDQUFDO1FBQ1g7UUFDQUc7WUFDRSxNQUFNTixhQUFhLElBQUksQ0FBQ08sT0FBTyxDQUFDO1lBQ2hDLE1BQU1DLGNBQWMsSUFBSSxDQUFDRCxPQUFPLENBQUM7WUFDakNqQiw4Q0FBTUEsQ0FBQ1UsWUFBWTtZQUNuQlYsOENBQU1BLENBQUMsT0FBT2tCLGdCQUFnQixVQUFVO1lBQ3hDLE1BQU1DLFFBQVFsQixTQUFTLENBQUNTLFVBQVUsQ0FBQ1EsWUFBWSxDQUFDO1lBRWhELElBQUlDLFVBQVVDLFdBQVc7Z0JBQ3ZCLGtDQUFrQztnQkFDbEMsSUFBSSxDQUFDQyxNQUFNO1lBQ2IsT0FBTztnQkFDTCxJQUFJLENBQUNULGtCQUFrQjtnQkFDdkIsSUFBSSxDQUFDQyxHQUFHLENBQUMsUUFBUU0sUUFBUTtZQUMzQjtRQUNGO1FBQ0FHO1lBQ0UsSUFBSSxDQUFDVixrQkFBa0I7WUFDdkIsSUFBSSxDQUFDQyxHQUFHLENBQUM7UUFDWDtRQUNBVTtZQUNFLE1BQU1iLGFBQWEsSUFBSSxDQUFDTyxP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ZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWJsZS9kZXYvbGliL2h0bWwuanM/ZWE2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuSHRtbEV4dGVuc2lvbn0gSHRtbEV4dGVuc2lvblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9pbmZlci5qcycpLkFsaWdufSBBbGlnblxuICovXG5cbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICd1dnUvYXNzZXJ0J1xuXG5jb25zdCBhbGlnbm1lbnQgPSB7XG4gIG5vbmU6ICcnLFxuICBsZWZ0OiAnIGFsaWduPVwibGVmdFwiJyxcbiAgcmlnaHQ6ICcgYWxpZ249XCJyaWdodFwiJyxcbiAgY2VudGVyOiAnIGFsaWduPVwiY2VudGVyXCInXG59XG5cbi8vIFRvIGRvOiBuZXh0IG1ham9yOiBleHBvc2UgZnVuY3Rpb25zLlxuLy8gVG8gZG86IG5leHQgbWFqb3I6IHVzZSBgaW5mZXJgIGhlcmUsIHdoZW4gYWxsIGV2ZW50cyBhcmUgZXhwb3NlZC5cblxuLyoqXG4gKiBFeHRlbnNpb24gZm9yIGBtaWNyb21hcmtgIHRoYXQgY2FuIGJlIHBhc3NlZCBpbiBgaHRtbEV4dGVuc2lvbnNgIHRvIHN1cHBvcnRcbiAqIEdGTSB0YWJsZXMgd2hlbiBzZXJpYWxpemluZyB0byBIVE1MLlxuICpcbiAqIEB0eXBlIHtIdG1sRXh0ZW5zaW9ufVxuICovXG5leHBvcnQgY29uc3QgZ2ZtVGFibGVIdG1sID0ge1xuICBlbnRlcjoge1xuICAgIHRhYmxlKHRva2VuKSB7XG4gICAgICBjb25zdCB0YWJsZUFsaWduID0gdG9rZW4uX2FsaWduXG4gICAgICBhc3NlcnQodGFibGVBbGlnbiwgJ2V4cGVjdGVkIGBfYWxpZ25gJylcbiAgICAgIHRoaXMubGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICAgIHRoaXMudGFnKCc8dGFibGU+JylcbiAgICAgIHRoaXMuc2V0RGF0YSgndGFibGVBbGlnbicsIHRhYmxlQWxpZ24pXG4gICAgfSxcbiAgICB0YWJsZUJvZHkoKSB7XG4gICAgICB0aGlzLnRhZygnPHRib2R5PicpXG4gICAgfSxcbiAgICB0YWJsZURhdGEoKSB7XG4gICAgICBjb25zdCB0YWJsZUFsaWduID0gdGhpcy5nZXREYXRhKCd0YWJsZUFsaWduJylcbiAgICAgIGNvbnN0IHRhYmxlQ29sdW1uID0gdGhpcy5nZXREYXRhKCd0YWJsZUNvbHVtbicpXG4gICAgICBhc3NlcnQodGFibGVBbGlnbiwgJ2V4cGVjdGVkIGB0YWJsZUFsaWduYCcpXG4gICAgICBhc3NlcnQodHlwZW9mIHRhYmxlQ29sdW1uID09PSAnbnVtYmVyJywgJ2V4cGVjdGVkIGB0YWJsZUNvbHVtbmAnKVxuICAgICAgY29uc3QgYWxpZ24gPSBhbGlnbm1lbnRbdGFibGVBbGlnblt0YWJsZUNvbHVtbl1dXG5cbiAgICAgIGlmIChhbGlnbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIENhcHR1cmUgcmVzdWx0cyB0byBpZ25vcmUgdGhlbS5cbiAgICAgICAgdGhpcy5idWZmZXIoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5saW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgICAgICB0aGlzLnRhZygnPHRkJyArIGFsaWduICsgJz4nKVxuICAgICAgfVxuICAgIH0sXG4gICAgdGFibGVIZWFkKCkge1xuICAgICAgdGhpcy5saW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgICAgdGhpcy50YWcoJzx0aGVhZD4nKVxuICAgIH0sXG4gICAgdGFibGVIZWFkZXIoKSB7XG4gICAgICBjb25zdCB0YWJsZUFsaWduID0gdGhpcy5nZXREYXRhKCd0YWJsZUFsaWduJylcbiAgICAgIGNvbnN0IHRhYmxlQ29sdW1uID0gdGhpcy5nZXREYXRhKCd0YWJsZUNvbHVtbicpXG4gICAgICBhc3NlcnQodGFibGVBbGlnbiwgJ2V4cGVjdGVkIGB0YWJsZUFsaWduYCcpXG4gICAgICBhc3NlcnQodHlwZW9mIHRhYmxlQ29sdW1uID09PSAnbnVtYmVyJywgJ2V4cGVjdGVkIGB0YWJsZUNvbHVtbmAnKVxuICAgICAgY29uc3QgYWxpZ24gPSBhbGlnbm1lbnRbdGFibGVBbGlnblt0YWJsZUNvbHVtbl1dXG4gICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICB0aGlzLnRhZygnPHRoJyArIGFsaWduICsgJz4nKVxuICAgIH0sXG4gICAgdGFibGVSb3coKSB7XG4gICAgICB0aGlzLnNldERhdGEoJ3RhYmxlQ29sdW1uJywgMClcbiAgICAgIHRoaXMubGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICAgIHRoaXMudGFnKCc8dHI+JylcbiAgICB9XG4gIH0sXG4gIGV4aXQ6IHtcbiAgICAvLyBPdmVyd3JpdGUgdGhlIGRlZmF1bHQgY29kZSB0ZXh0IGRhdGEgaGFuZGxlciB0byB1bmVzY2FwZSBlc2NhcGVkIHBpcGVzIHdoZW5cbiAgICAvLyB0aGV5IGFyZSBpbiB0YWJsZXMuXG4gICAgY29kZVRleHREYXRhKHRva2VuKSB7XG4gICAgICBsZXQgdmFsdWUgPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuXG4gICAgICBpZiAodGhpcy5nZXREYXRhKCd0YWJsZUFsaWduJykpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcKFtcXFxcfF0pL2csIHJlcGxhY2UpXG4gICAgICB9XG5cbiAgICAgIHRoaXMucmF3KHRoaXMuZW5jb2RlKHZhbHVlKSlcbiAgICB9LFxuICAgIHRhYmxlKCkge1xuICAgICAgdGhpcy5zZXREYXRhKCd0YWJsZUFsaWduJylcbiAgICAgIC8vIE5vdGU6IHdlIGRvbuKAmXQgc2V0IGBzbHVycEFsbExpbmVFbmRpbmdzYCBhbnltb3JlLCBpbiBkZWxpbWl0ZXIgcm93cyxcbiAgICAgIC8vIGJ1dCB3ZSBkbyBuZWVkIHRvIHJlc2V0IGl0IHRvIG1hdGNoIGEgZnVua3kgbmV3bGluZSBHSCBnZW5lcmF0ZXMgZm9yXG4gICAgICAvLyBsaXN0IGl0ZW1zIGNvbWJpbmVkIHdpdGggdGFibGVzLlxuICAgICAgdGhpcy5zZXREYXRhKCdzbHVycEFsbExpbmVFbmRpbmdzJylcbiAgICAgIHRoaXMubGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICAgIHRoaXMudGFnKCc8L3RhYmxlPicpXG4gICAgfSxcbiAgICB0YWJsZUJvZHkoKSB7XG4gICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICB0aGlzLnRhZygnPC90Ym9keT4nKVxuICAgIH0sXG4gICAgdGFibGVEYXRhKCkge1xuICAgICAgY29uc3QgdGFibGVBbGlnbiA9IHRoaXMuZ2V0RGF0YSgndGFibGVBbGlnbicpXG4gICAgICBjb25zdCB0YWJsZUNvbHVtbiA9IHRoaXMuZ2V0RGF0YSgndGFibGVDb2x1bW4nKVxuICAgICAgYXNzZXJ0KHRhYmxlQWxpZ24sICdleHBlY3RlZCBgdGFibGVBbGlnbmAnKVxuICAgICAgYXNzZXJ0KHR5cGVvZiB0YWJsZUNvbHVtbiA9PT0gJ251bWJlcicsICdleHBlY3RlZCBgdGFibGVDb2x1bW5gJylcblxuICAgICAgaWYgKHRhYmxlQ29sdW1uIGluIHRhYmxlQWxpZ24pIHtcbiAgICAgICAgdGhpcy50YWcoJzwvdGQ+JylcbiAgICAgICAgdGhpcy5zZXREYXRhKCd0YWJsZUNvbHVtbicsIHRhYmxlQ29sdW1uICsgMSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFN0b3AgY2FwdHVyaW5nLlxuICAgICAgICB0aGlzLnJlc3VtZSgpXG4gICAgICB9XG4gICAgfSxcbiAgICB0YWJsZUhlYWQoKSB7XG4gICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICB0aGlzLnRhZygnPC90aGVhZD4nKVxuICAgIH0sXG4gICAgdGFibGVIZWFkZXIoKSB7XG4gICAgICBjb25zdCB0YWJsZUNvbHVtbiA9IHRoaXMuZ2V0RGF0YSgndGFibGVDb2x1bW4nKVxuICAgICAgYXNzZXJ0KHR5cGVvZiB0YWJsZUNvbHVtbiA9PT0gJ251bWJlcicsICdleHBlY3RlZCBgdGFibGVDb2x1bW5gJylcbiAgICAgIHRoaXMudGFnKCc8L3RoPicpXG4gICAgICB0aGlzLnNldERhdGEoJ3RhYmxlQ29sdW1uJywgdGFibGVDb2x1bW4gKyAxKVxuICAgIH0sXG4gICAgdGFibGVSb3coKSB7XG4gICAgICBjb25zdCB0YWJsZUFsaWduID0gdGhpcy5nZXREYXRhKCd0YWJsZUFsaWduJylcbiAgICAgIGxldCB0YWJsZUNvbHVtbiA9IHRoaXMuZ2V0RGF0YSgndGFibGVDb2x1bW4nKVxuICAgICAgYXNzZXJ0KHRhYmxlQWxpZ24sICdleHBlY3RlZCBgdGFibGVBbGlnbmAnKVxuICAgICAgYXNzZXJ0KHR5cGVvZiB0YWJsZUNvbHVtbiA9PT0gJ251bWJlcicsICdleHBlY3RlZCBgdGFibGVDb2x1bW5gJylcblxuICAgICAgd2hpbGUgKHRhYmxlQ29sdW1uIDwgdGFibGVBbGlnbi5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5saW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgICAgICB0aGlzLnRhZygnPHRkJyArIGFsaWdubWVudFt0YWJsZUFsaWduW3RhYmxlQ29sdW1uXV0gKyAnPjwvdGQ+JylcbiAgICAgICAgdGFibGVDb2x1bW4rK1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldERhdGEoJ3RhYmxlQ29sdW1uJywgdGFibGVDb2x1bW4pXG4gICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICB0aGlzLnRhZygnPC90cj4nKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSAkMFxuICogQHBhcmFtIHtzdHJpbmd9ICQxXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByZXBsYWNlKCQwLCAkMSkge1xuICAvLyBQaXBlcyB3b3JrLCBiYWNrc2xhc2hlcyBkb27igJl0IChidXQgY2Fu4oCZdCBlc2NhcGUgcGlwZXMpLlxuICByZXR1cm4gJDEgPT09ICd8JyA/ICQxIDogJDBcbn1cbiJdLCJuYW1lcyI6WyJvayIsImFzc2VydCIsImFsaWdubWVudCIsIm5vbmUiLCJsZWZ0IiwicmlnaHQiLCJjZW50ZXIiLCJnZm1UYWJsZUh0bWwiLCJlbnRlciIsInRhYmxlIiwidG9rZW4iLCJ0YWJsZUFsaWduIiwiX2FsaWduIiwibGluZUVuZGluZ0lmTmVlZGVkIiwidGFnIiwic2V0RGF0YSIsInRhYmxlQm9keSIsInRhYmxlRGF0YSIsImdldERhdGEiLCJ0YWJsZUNvbHVtbiIsImFsaWduIiwidW5kZWZpbmVkIiwiYnVmZmVyIiwidGFibGVIZWFkIiwidGFibGVIZWFkZXIiLCJ0YWJsZVJvdyIsImV4aXQiLCJjb2RlVGV4dERhdGEiLCJ2YWx1ZSIsInNsaWNlU2VyaWFsaXplIiwicmVwbGFjZSIsInJhdyIsImVuY29kZSIsInJlc3VtZSIsImxlbmd0aCIsIiQwIiwiJDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/micromark-extension-gfm-table/dev/lib/html.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/micromark-extension-gfm-table/dev/lib/infer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/dev/lib/infer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTableAlign: () => (/* binding */ gfmTableAlign)\n/* harmony export */ });\n/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uvu/assert */ \"(rsc)/./node_modules/uvu/assert/index.mjs\");\n/**\n * @typedef {import('micromark-util-types').Event} Event\n */ /**\n * @typedef {'left' | 'center' | 'right' | 'none'} Align\n */ \n/**\n * Figure out the alignment of a GFM table.\n *\n * @param {Array<Event>} events\n * @param {number} index\n * @returns {Array<Align>}\n */ function gfmTableAlign(events, index) {\n    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(events[index][1].type === \"table\", \"expected table\");\n    let inDelimiterRow = false;\n    /** @type {Array<Align>} */ const align = [];\n    while(index < events.length){\n        const event = events[index];\n        if (inDelimiterRow) {\n            if (event[0] === \"enter\") {\n                // Start of alignment value: set a new column.\n                // To do: `markdown-rs` uses `tableDelimiterCellValue`.\n                if (event[1].type === \"tableContent\") {\n                    align.push(events[index + 1][1].type === \"tableDelimiterMarker\" ? \"left\" : \"none\");\n                }\n            } else if (event[1].type === \"tableContent\") {\n                if (events[index - 1][1].type === \"tableDelimiterMarker\") {\n                    const alignIndex = align.length - 1;\n                    align[alignIndex] = align[alignIndex] === \"left\" ? \"center\" : \"right\";\n                }\n            } else if (event[1].type === \"tableDelimiterRow\") {\n                break;\n            }\n        } else if (event[0] === \"enter\" && event[1].type === \"tableDelimiterRow\") {\n            inDelimiterRow = true;\n        }\n        index += 1;\n    }\n    return align;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvZGV2L2xpYi9pbmZlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztDQUVDLEdBRUQ7O0NBRUMsR0FFc0M7QUFFdkM7Ozs7OztDQU1DLEdBQ00sU0FBU0UsY0FBY0MsTUFBTSxFQUFFQyxLQUFLO0lBQ3pDSCw4Q0FBTUEsQ0FBQ0UsTUFBTSxDQUFDQyxNQUFNLENBQUMsRUFBRSxDQUFDQyxJQUFJLEtBQUssU0FBUztJQUMxQyxJQUFJQyxpQkFBaUI7SUFDckIseUJBQXlCLEdBQ3pCLE1BQU1DLFFBQVEsRUFBRTtJQUVoQixNQUFPSCxRQUFRRCxPQUFPSyxNQUFNLENBQUU7UUFDNUIsTUFBTUMsUUFBUU4sTUFBTSxDQUFDQyxNQUFNO1FBRTNCLElBQUlFLGdCQUFnQjtZQUNsQixJQUFJRyxLQUFLLENBQUMsRUFBRSxLQUFLLFNBQVM7Z0JBQ3hCLDhDQUE4QztnQkFDOUMsdURBQXVEO2dCQUN2RCxJQUFJQSxLQUFLLENBQUMsRUFBRSxDQUFDSixJQUFJLEtBQUssZ0JBQWdCO29CQUNwQ0UsTUFBTUcsSUFBSSxDQUNSUCxNQUFNLENBQUNDLFFBQVEsRUFBRSxDQUFDLEVBQUUsQ0FBQ0MsSUFBSSxLQUFLLHlCQUMxQixTQUNBO2dCQUVSO1lBQ0YsT0FJSyxJQUFJSSxLQUFLLENBQUMsRUFBRSxDQUFDSixJQUFJLEtBQUssZ0JBQWdCO2dCQUN6QyxJQUFJRixNQUFNLENBQUNDLFFBQVEsRUFBRSxDQUFDLEVBQUUsQ0FBQ0MsSUFBSSxLQUFLLHdCQUF3QjtvQkFDeEQsTUFBTU0sYUFBYUosTUFBTUMsTUFBTSxHQUFHO29CQUVsQ0QsS0FBSyxDQUFDSSxXQUFXLEdBQUdKLEtBQUssQ0FBQ0ksV0FBVyxLQUFLLFNBQVMsV0FBVztnQkFDaEU7WUFDRixPQUVLLElBQUlGLEtBQUssQ0FBQyxFQUFFLENBQUNKLElBQUksS0FBSyxxQkFBcUI7Z0JBQzlDO1lBQ0Y7UUFDRixPQUFPLElBQUlJLEtBQUssQ0FBQyxFQUFFLEtBQUssV0FBV0EsS0FBSyxDQUFDLEVBQUUsQ0FBQ0osSUFBSSxLQUFLLHFCQUFxQjtZQUN4RUMsaUJBQWlCO1FBQ25CO1FBRUFGLFNBQVM7SUFDWDtJQUVBLE9BQU9HO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0cGxhdGUvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvZGV2L2xpYi9pbmZlci5qcz81MTY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FdmVudH0gRXZlbnRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnbGVmdCcgfCAnY2VudGVyJyB8ICdyaWdodCcgfCAnbm9uZSd9IEFsaWduXG4gKi9cblxuaW1wb3J0IHtvayBhcyBhc3NlcnR9IGZyb20gJ3V2dS9hc3NlcnQnXG5cbi8qKlxuICogRmlndXJlIG91dCB0aGUgYWxpZ25tZW50IG9mIGEgR0ZNIHRhYmxlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBldmVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybnMge0FycmF5PEFsaWduPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbVRhYmxlQWxpZ24oZXZlbnRzLCBpbmRleCkge1xuICBhc3NlcnQoZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAndGFibGUnLCAnZXhwZWN0ZWQgdGFibGUnKVxuICBsZXQgaW5EZWxpbWl0ZXJSb3cgPSBmYWxzZVxuICAvKiogQHR5cGUge0FycmF5PEFsaWduPn0gKi9cbiAgY29uc3QgYWxpZ24gPSBbXVxuXG4gIHdoaWxlIChpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICBjb25zdCBldmVudCA9IGV2ZW50c1tpbmRleF1cblxuICAgIGlmIChpbkRlbGltaXRlclJvdykge1xuICAgICAgaWYgKGV2ZW50WzBdID09PSAnZW50ZXInKSB7XG4gICAgICAgIC8vIFN0YXJ0IG9mIGFsaWdubWVudCB2YWx1ZTogc2V0IGEgbmV3IGNvbHVtbi5cbiAgICAgICAgLy8gVG8gZG86IGBtYXJrZG93bi1yc2AgdXNlcyBgdGFibGVEZWxpbWl0ZXJDZWxsVmFsdWVgLlxuICAgICAgICBpZiAoZXZlbnRbMV0udHlwZSA9PT0gJ3RhYmxlQ29udGVudCcpIHtcbiAgICAgICAgICBhbGlnbi5wdXNoKFxuICAgICAgICAgICAgZXZlbnRzW2luZGV4ICsgMV1bMV0udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyTWFya2VyJ1xuICAgICAgICAgICAgICA/ICdsZWZ0J1xuICAgICAgICAgICAgICA6ICdub25lJ1xuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRXhpdHM6XG4gICAgICAvLyBFbmQgb2YgYWxpZ25tZW50IHZhbHVlOiBjaGFuZ2UgdGhlIGNvbHVtbi5cbiAgICAgIC8vIFRvIGRvOiBgbWFya2Rvd24tcnNgIHVzZXMgYHRhYmxlRGVsaW1pdGVyQ2VsbFZhbHVlYC5cbiAgICAgIGVsc2UgaWYgKGV2ZW50WzFdLnR5cGUgPT09ICd0YWJsZUNvbnRlbnQnKSB7XG4gICAgICAgIGlmIChldmVudHNbaW5kZXggLSAxXVsxXS50eXBlID09PSAndGFibGVEZWxpbWl0ZXJNYXJrZXInKSB7XG4gICAgICAgICAgY29uc3QgYWxpZ25JbmRleCA9IGFsaWduLmxlbmd0aCAtIDFcblxuICAgICAgICAgIGFsaWduW2FsaWduSW5kZXhdID0gYWxpZ25bYWxpZ25JbmRleF0gPT09ICdsZWZ0JyA/ICdjZW50ZXInIDogJ3JpZ2h0J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBEb25lIVxuICAgICAgZWxzZSBpZiAoZXZlbnRbMV0udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyUm93Jykge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXZlbnRbMF0gPT09ICdlbnRlcicgJiYgZXZlbnRbMV0udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyUm93Jykge1xuICAgICAgaW5EZWxpbWl0ZXJSb3cgPSB0cnVlXG4gICAgfVxuXG4gICAgaW5kZXggKz0gMVxuICB9XG5cbiAgcmV0dXJuIGFsaWduXG59XG4iXSwibmFtZXMiOlsib2siLCJhc3NlcnQiLCJnZm1UYWJsZUFsaWduIiwiZXZlbnRzIiwiaW5kZXgiLCJ0eXBlIiwiaW5EZWxpbWl0ZXJSb3ciLCJhbGlnbiIsImxlbmd0aCIsImV2ZW50IiwicHVzaCIsImFsaWduSW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/micromark-extension-gfm-table/dev/lib/infer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/micromark-extension-gfm-table/dev/lib/syntax.js":
/*!**********************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/dev/lib/syntax.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTable: () => (/* binding */ gfmTable)\n/* harmony export */ });\n/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uvu/assert */ \"(rsc)/./node_modules/uvu/assert/index.mjs\");\n/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-factory-space */ \"(rsc)/./node_modules/micromark-factory-space/dev/index.js\");\n/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-character */ \"(rsc)/./node_modules/micromark-util-character/dev/index.js\");\n/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ \"(rsc)/./node_modules/micromark-util-symbol/codes.js\");\n/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ \"(rsc)/./node_modules/micromark-util-symbol/constants.js\");\n/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol/types.js */ \"(rsc)/./node_modules/micromark-util-symbol/types.js\");\n/* harmony import */ var _edit_map_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./edit-map.js */ \"(rsc)/./node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js\");\n/* harmony import */ var _infer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./infer.js */ \"(rsc)/./node_modules/micromark-extension-gfm-table/dev/lib/infer.js\");\n/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */ /**\n * @typedef {[number, number, number, number]} Range\n *   Cell info.\n *\n * @typedef {0 | 1 | 2 | 3} RowKind\n *   Where we are: `1` for head row, `2` for delimiter row, `3` for body row.\n */ \n\n\n\n\n\n\n\n// To do: next major: expose functions.\n/**\n * Extension for `micromark` that can be passed in `extensions` to enable GFM\n * table syntax.\n *\n * @type {Extension}\n */ const gfmTable = {\n    flow: {\n        null: {\n            tokenize: tokenizeTable,\n            resolveAll: resolveTable\n        }\n    }\n};\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */ function tokenizeTable(effects, ok, nok) {\n    const self = this;\n    let size = 0;\n    let sizeB = 0;\n    /** @type {boolean | undefined} */ let seen;\n    return start;\n    /**\n   * Start of a GFM table.\n   *\n   * If there is a valid table row or table head before, then we try to parse\n   * another row.\n   * Otherwise, we try to parse a head.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   * > | | b |\n   *     ^\n   * ```\n   * @type {State}\n   */ function start(code) {\n        let index = self.events.length - 1;\n        while(index > -1){\n            const type = self.events[index][1].type;\n            if (type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.lineEnding || // Note: markdown-rs uses `whitespace` instead of `linePrefix`\n            type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.linePrefix) index--;\n            else break;\n        }\n        const tail = index > -1 ? self.events[index][1].type : null;\n        const next = tail === \"tableHead\" || tail === \"tableRow\" ? bodyRowStart : headRowBefore;\n        // Don’t allow lazy body rows.\n        if (next === bodyRowStart && self.parser.lazy[self.now().line]) {\n            return nok(code);\n        }\n        return next(code);\n    }\n    /**\n   * Before table head row.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */ function headRowBefore(code) {\n        effects.enter(\"tableHead\");\n        effects.enter(\"tableRow\");\n        return headRowStart(code);\n    }\n    /**\n   * Before table head row, after whitespace.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */ function headRowStart(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.verticalBar) {\n            return headRowBreak(code);\n        }\n        // To do: micromark-js should let us parse our own whitespace in extensions,\n        // like `markdown-rs`:\n        //\n        // ```js\n        // // 4+ spaces.\n        // if (markdownSpace(code)) {\n        //   return nok(code)\n        // }\n        // ```\n        seen = true;\n        // Count the first character, that isn’t a pipe, double.\n        sizeB += 1;\n        return headRowBreak(code);\n    }\n    /**\n   * At break in table head row.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *       ^\n   *         ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */ function headRowBreak(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof) {\n            // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n            return nok(code);\n        }\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEnding)(code)) {\n            // If anything other than one pipe (ignoring whitespace) was used, it’s fine.\n            if (sizeB > 1) {\n                sizeB = 0;\n                // To do: check if this works.\n                // Feel free to interrupt:\n                self.interrupt = true;\n                effects.exit(\"tableRow\");\n                effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.lineEnding);\n                effects.consume(code);\n                effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.lineEnding);\n                return headDelimiterStart;\n            }\n            // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n            return nok(code);\n        }\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownSpace)(code)) {\n            // To do: check if this is fine.\n            // effects.attempt(State::Next(StateName::GfmTableHeadRowBreak), State::Nok)\n            // State::Retry(space_or_tab(tokenizer))\n            return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_4__.factorySpace)(effects, headRowBreak, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.whitespace)(code);\n        }\n        sizeB += 1;\n        if (seen) {\n            seen = false;\n            // Header cell count.\n            size += 1;\n        }\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.verticalBar) {\n            effects.enter(\"tableCellDivider\");\n            effects.consume(code);\n            effects.exit(\"tableCellDivider\");\n            // Whether a delimiter was seen.\n            seen = true;\n            return headRowBreak;\n        }\n        // Anything else is cell data.\n        effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.data);\n        return headRowData(code);\n    }\n    /**\n   * In table head row data.\n   *\n   * ```markdown\n   * > | | a |\n   *       ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */ function headRowData(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.verticalBar || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEndingOrSpace)(code)) {\n            effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.data);\n            return headRowBreak(code);\n        }\n        effects.consume(code);\n        return code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.backslash ? headRowEscape : headRowData;\n    }\n    /**\n   * In table head row escape.\n   *\n   * ```markdown\n   * > | | a\\-b |\n   *         ^\n   *   | | ---- |\n   *   | | c    |\n   * ```\n   *\n   * @type {State}\n   */ function headRowEscape(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.backslash || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.verticalBar) {\n            effects.consume(code);\n            return headRowData;\n        }\n        return headRowData(code);\n    }\n    /**\n   * Before delimiter row.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *     ^\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterStart(code) {\n        // Reset `interrupt`.\n        self.interrupt = false;\n        // Note: in `markdown-rs`, we need to handle piercing here too.\n        if (self.parser.lazy[self.now().line]) {\n            return nok(code);\n        }\n        effects.enter(\"tableDelimiterRow\");\n        // Track if we’ve seen a `:` or `|`.\n        seen = false;\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownSpace)(code)) {\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(self.parser.constructs.disable.null, \"expected `disabled.null`\");\n            return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_4__.factorySpace)(effects, headDelimiterBefore, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.linePrefix, self.parser.constructs.disable.null.includes(\"codeIndented\") ? undefined : micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_5__.constants.tabSize)(code);\n        }\n        return headDelimiterBefore(code);\n    }\n    /**\n   * Before delimiter row, after optional whitespace.\n   *\n   * Reused when a `|` is found later, to parse another cell.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *     ^\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterBefore(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.colon) {\n            return headDelimiterValueBefore(code);\n        }\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.verticalBar) {\n            seen = true;\n            // If we start with a pipe, we open a cell marker.\n            effects.enter(\"tableCellDivider\");\n            effects.consume(code);\n            effects.exit(\"tableCellDivider\");\n            return headDelimiterCellBefore;\n        }\n        // More whitespace / empty row not allowed at start.\n        return headDelimiterNok(code);\n    }\n    /**\n   * After `|`, before delimiter cell.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterCellBefore(code) {\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownSpace)(code)) {\n            return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_4__.factorySpace)(effects, headDelimiterValueBefore, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.whitespace)(code);\n        }\n        return headDelimiterValueBefore(code);\n    }\n    /**\n   * Before delimiter cell value.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterValueBefore(code) {\n        // Align: left.\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.colon) {\n            sizeB += 1;\n            seen = true;\n            effects.enter(\"tableDelimiterMarker\");\n            effects.consume(code);\n            effects.exit(\"tableDelimiterMarker\");\n            return headDelimiterLeftAlignmentAfter;\n        }\n        // Align: none.\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash) {\n            sizeB += 1;\n            // To do: seems weird that this *isn’t* left aligned, but that state is used?\n            return headDelimiterLeftAlignmentAfter(code);\n        }\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEnding)(code)) {\n            return headDelimiterCellAfter(code);\n        }\n        return headDelimiterNok(code);\n    }\n    /**\n   * After delimiter cell left alignment marker.\n   *\n   * ```markdown\n   *   | | a  |\n   * > | | :- |\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterLeftAlignmentAfter(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash) {\n            effects.enter(\"tableDelimiterFiller\");\n            return headDelimiterFiller(code);\n        }\n        // Anything else is not ok after the left-align colon.\n        return headDelimiterNok(code);\n    }\n    /**\n   * In delimiter cell filler.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterFiller(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash) {\n            effects.consume(code);\n            return headDelimiterFiller;\n        }\n        // Align is `center` if it was `left`, `right` otherwise.\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.colon) {\n            seen = true;\n            effects.exit(\"tableDelimiterFiller\");\n            effects.enter(\"tableDelimiterMarker\");\n            effects.consume(code);\n            effects.exit(\"tableDelimiterMarker\");\n            return headDelimiterRightAlignmentAfter;\n        }\n        effects.exit(\"tableDelimiterFiller\");\n        return headDelimiterRightAlignmentAfter(code);\n    }\n    /**\n   * After delimiter cell right alignment marker.\n   *\n   * ```markdown\n   *   | |  a |\n   * > | | -: |\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterRightAlignmentAfter(code) {\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownSpace)(code)) {\n            return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_4__.factorySpace)(effects, headDelimiterCellAfter, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.whitespace)(code);\n        }\n        return headDelimiterCellAfter(code);\n    }\n    /**\n   * After delimiter cell.\n   *\n   * ```markdown\n   *   | |  a |\n   * > | | -: |\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterCellAfter(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.verticalBar) {\n            return headDelimiterBefore(code);\n        }\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEnding)(code)) {\n            // Exit when:\n            // * there was no `:` or `|` at all (it’s a thematic break or setext\n            //   underline instead)\n            // * the header cell count is not the delimiter cell count\n            if (!seen || size !== sizeB) {\n                return headDelimiterNok(code);\n            }\n            // Note: in markdown-rs`, a reset is needed here.\n            effects.exit(\"tableDelimiterRow\");\n            effects.exit(\"tableHead\");\n            // To do: in `markdown-rs`, resolvers need to be registered manually.\n            // effects.register_resolver(ResolveName::GfmTable)\n            return ok(code);\n        }\n        return headDelimiterNok(code);\n    }\n    /**\n   * In delimiter row, at a disallowed byte.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | x |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterNok(code) {\n        // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n        return nok(code);\n    }\n    /**\n   * Before table body row.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */ function bodyRowStart(code) {\n        // Note: in `markdown-rs` we need to manually take care of a prefix,\n        // but in `micromark-js` that is done for us, so if we’re here, we’re\n        // never at whitespace.\n        effects.enter(\"tableRow\");\n        return bodyRowBreak(code);\n    }\n    /**\n   * At break in table body row.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *     ^\n   *       ^\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */ function bodyRowBreak(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.verticalBar) {\n            effects.enter(\"tableCellDivider\");\n            effects.consume(code);\n            effects.exit(\"tableCellDivider\");\n            return bodyRowBreak;\n        }\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEnding)(code)) {\n            effects.exit(\"tableRow\");\n            return ok(code);\n        }\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownSpace)(code)) {\n            return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_4__.factorySpace)(effects, bodyRowBreak, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.whitespace)(code);\n        }\n        // Anything else is cell content.\n        effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.data);\n        return bodyRowData(code);\n    }\n    /**\n   * In table body row data.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */ function bodyRowData(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.verticalBar || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEndingOrSpace)(code)) {\n            effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.data);\n            return bodyRowBreak(code);\n        }\n        effects.consume(code);\n        return code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.backslash ? bodyRowEscape : bodyRowData;\n    }\n    /**\n   * In table body row escape.\n   *\n   * ```markdown\n   *   | | a    |\n   *   | | ---- |\n   * > | | b\\-c |\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */ function bodyRowEscape(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.backslash || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.verticalBar) {\n            effects.consume(code);\n            return bodyRowData;\n        }\n        return bodyRowData(code);\n    }\n}\n/** @type {Resolver} */ // eslint-disable-next-line complexity\nfunction resolveTable(events, context) {\n    let index = -1;\n    let inFirstCellAwaitingPipe = true;\n    /** @type {RowKind} */ let rowKind = 0;\n    /** @type {Range} */ let lastCell = [\n        0,\n        0,\n        0,\n        0\n    ];\n    /** @type {Range} */ let cell = [\n        0,\n        0,\n        0,\n        0\n    ];\n    let afterHeadAwaitingFirstBodyRow = false;\n    let lastTableEnd = 0;\n    /** @type {Token | undefined} */ let currentTable;\n    /** @type {Token | undefined} */ let currentBody;\n    /** @type {Token | undefined} */ let currentCell;\n    const map = new _edit_map_js__WEBPACK_IMPORTED_MODULE_6__.EditMap();\n    while(++index < events.length){\n        const event = events[index];\n        const token = event[1];\n        if (event[0] === \"enter\") {\n            // Start of head.\n            if (token.type === \"tableHead\") {\n                afterHeadAwaitingFirstBodyRow = false;\n                // Inject previous (body end and) table end.\n                if (lastTableEnd !== 0) {\n                    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(currentTable, \"there should be a table opening\");\n                    flushTableEnd(map, context, lastTableEnd, currentTable, currentBody);\n                    currentBody = undefined;\n                    lastTableEnd = 0;\n                }\n                // Inject table start.\n                currentTable = {\n                    type: \"table\",\n                    start: Object.assign({}, token.start),\n                    // Note: correct end is set later.\n                    end: Object.assign({}, token.end)\n                };\n                map.add(index, 0, [\n                    [\n                        \"enter\",\n                        currentTable,\n                        context\n                    ]\n                ]);\n            } else if (token.type === \"tableRow\" || token.type === \"tableDelimiterRow\") {\n                inFirstCellAwaitingPipe = true;\n                currentCell = undefined;\n                lastCell = [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n                cell = [\n                    0,\n                    index + 1,\n                    0,\n                    0\n                ];\n                // Inject table body start.\n                if (afterHeadAwaitingFirstBodyRow) {\n                    afterHeadAwaitingFirstBodyRow = false;\n                    currentBody = {\n                        type: \"tableBody\",\n                        start: Object.assign({}, token.start),\n                        // Note: correct end is set later.\n                        end: Object.assign({}, token.end)\n                    };\n                    map.add(index, 0, [\n                        [\n                            \"enter\",\n                            currentBody,\n                            context\n                        ]\n                    ]);\n                }\n                rowKind = token.type === \"tableDelimiterRow\" ? 2 : currentBody ? 3 : 1;\n            } else if (rowKind && (token.type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.data || token.type === \"tableDelimiterMarker\" || token.type === \"tableDelimiterFiller\")) {\n                inFirstCellAwaitingPipe = false;\n                // First value in cell.\n                if (cell[2] === 0) {\n                    if (lastCell[1] !== 0) {\n                        cell[0] = cell[1];\n                        currentCell = flushCell(map, context, lastCell, rowKind, undefined, currentCell);\n                        lastCell = [\n                            0,\n                            0,\n                            0,\n                            0\n                        ];\n                    }\n                    cell[2] = index;\n                }\n            } else if (token.type === \"tableCellDivider\") {\n                if (inFirstCellAwaitingPipe) {\n                    inFirstCellAwaitingPipe = false;\n                } else {\n                    if (lastCell[1] !== 0) {\n                        cell[0] = cell[1];\n                        currentCell = flushCell(map, context, lastCell, rowKind, undefined, currentCell);\n                    }\n                    lastCell = cell;\n                    cell = [\n                        lastCell[1],\n                        index,\n                        0,\n                        0\n                    ];\n                }\n            }\n        } else if (token.type === \"tableHead\") {\n            afterHeadAwaitingFirstBodyRow = true;\n            lastTableEnd = index;\n        } else if (token.type === \"tableRow\" || token.type === \"tableDelimiterRow\") {\n            lastTableEnd = index;\n            if (lastCell[1] !== 0) {\n                cell[0] = cell[1];\n                currentCell = flushCell(map, context, lastCell, rowKind, index, currentCell);\n            } else if (cell[1] !== 0) {\n                currentCell = flushCell(map, context, cell, rowKind, index, currentCell);\n            }\n            rowKind = 0;\n        } else if (rowKind && (token.type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.data || token.type === \"tableDelimiterMarker\" || token.type === \"tableDelimiterFiller\")) {\n            cell[3] = index;\n        }\n    }\n    if (lastTableEnd !== 0) {\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(currentTable, \"expected table opening\");\n        flushTableEnd(map, context, lastTableEnd, currentTable, currentBody);\n    }\n    map.consume(context.events);\n    // To do: move this into `html`, when events are exposed there.\n    // That’s what `markdown-rs` does.\n    // That needs updates to `mdast-util-gfm-table`.\n    index = -1;\n    while(++index < context.events.length){\n        const event = context.events[index];\n        if (event[0] === \"enter\" && event[1].type === \"table\") {\n            event[1]._align = (0,_infer_js__WEBPACK_IMPORTED_MODULE_7__.gfmTableAlign)(context.events, index);\n        }\n    }\n    return events;\n}\n/// Generate a cell.\n/**\n *\n * @param {EditMap} map\n * @param {TokenizeContext} context\n * @param {Range} range\n * @param {RowKind} rowKind\n * @param {number | undefined} rowEnd\n * @param {Token | undefined} previousCell\n * @returns {Token | undefined}\n */ // eslint-disable-next-line max-params\nfunction flushCell(map, context, range, rowKind, rowEnd, previousCell) {\n    // `markdown-rs` uses:\n    // rowKind === 2 ? 'tableDelimiterCell' : 'tableCell'\n    const groupName = rowKind === 1 ? \"tableHeader\" : rowKind === 2 ? \"tableDelimiter\" : \"tableData\";\n    // `markdown-rs` uses:\n    // rowKind === 2 ? 'tableDelimiterCellValue' : 'tableCellText'\n    const valueName = \"tableContent\";\n    // Insert an exit for the previous cell, if there is one.\n    //\n    // ```markdown\n    // > | | aa | bb | cc |\n    //          ^-- exit\n    //           ^^^^-- this cell\n    // ```\n    if (range[0] !== 0) {\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(previousCell, \"expected previous cell enter\");\n        previousCell.end = Object.assign({}, getPoint(context.events, range[0]));\n        map.add(range[0], 0, [\n            [\n                \"exit\",\n                previousCell,\n                context\n            ]\n        ]);\n    }\n    // Insert enter of this cell.\n    //\n    // ```markdown\n    // > | | aa | bb | cc |\n    //           ^-- enter\n    //           ^^^^-- this cell\n    // ```\n    const now = getPoint(context.events, range[1]);\n    previousCell = {\n        type: groupName,\n        start: Object.assign({}, now),\n        // Note: correct end is set later.\n        end: Object.assign({}, now)\n    };\n    map.add(range[1], 0, [\n        [\n            \"enter\",\n            previousCell,\n            context\n        ]\n    ]);\n    // Insert text start at first data start and end at last data end, and\n    // remove events between.\n    //\n    // ```markdown\n    // > | | aa | bb | cc |\n    //            ^-- enter\n    //             ^-- exit\n    //           ^^^^-- this cell\n    // ```\n    if (range[2] !== 0) {\n        const relatedStart = getPoint(context.events, range[2]);\n        const relatedEnd = getPoint(context.events, range[3]);\n        /** @type {Token} */ const valueToken = {\n            type: valueName,\n            start: Object.assign({}, relatedStart),\n            end: Object.assign({}, relatedEnd)\n        };\n        map.add(range[2], 0, [\n            [\n                \"enter\",\n                valueToken,\n                context\n            ]\n        ]);\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(range[3] !== 0);\n        if (rowKind !== 2) {\n            // Fix positional info on remaining events\n            const start = context.events[range[2]];\n            const end = context.events[range[3]];\n            start[1].end = Object.assign({}, end[1].end);\n            start[1].type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.chunkText;\n            start[1].contentType = micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_5__.constants.contentTypeText;\n            // Remove if needed.\n            if (range[3] > range[2] + 1) {\n                const a = range[2] + 1;\n                const b = range[3] - range[2] - 1;\n                map.add(a, b, []);\n            }\n        }\n        map.add(range[3] + 1, 0, [\n            [\n                \"exit\",\n                valueToken,\n                context\n            ]\n        ]);\n    }\n    // Insert an exit for the last cell, if at the row end.\n    //\n    // ```markdown\n    // > | | aa | bb | cc |\n    //                    ^-- exit\n    //               ^^^^^^-- this cell (the last one contains two “between” parts)\n    // ```\n    if (rowEnd !== undefined) {\n        previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));\n        map.add(rowEnd, 0, [\n            [\n                \"exit\",\n                previousCell,\n                context\n            ]\n        ]);\n        previousCell = undefined;\n    }\n    return previousCell;\n}\n/**\n * Generate table end (and table body end).\n *\n * @param {EditMap} map\n * @param {TokenizeContext} context\n * @param {number} index\n * @param {Token} table\n * @param {Token | undefined} tableBody\n */ // eslint-disable-next-line max-params\nfunction flushTableEnd(map, context, index, table, tableBody) {\n    /** @type {Array<Event>} */ const exits = [];\n    const related = getPoint(context.events, index);\n    if (tableBody) {\n        tableBody.end = Object.assign({}, related);\n        exits.push([\n            \"exit\",\n            tableBody,\n            context\n        ]);\n    }\n    table.end = Object.assign({}, related);\n    exits.push([\n        \"exit\",\n        table,\n        context\n    ]);\n    map.add(index + 1, 0, exits);\n}\n/**\n * @param {Array<Event>} events\n * @param {number} index\n * @returns {readonly Point}\n */ function getPoint(events, index) {\n    const event = events[index];\n    const side = event[0] === \"enter\" ? \"start\" : \"end\";\n    return event[1][side];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvZGV2L2xpYi9zeW50YXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLEdBRUQ7Ozs7OztDQU1DLEdBRXNDO0FBQ2E7QUFLbkI7QUFDbUI7QUFDUTtBQUNSO0FBQ2Y7QUFDRztBQUV4Qyx1Q0FBdUM7QUFFdkM7Ozs7O0NBS0MsR0FDTSxNQUFNVyxXQUFXO0lBQ3RCQyxNQUFNO1FBQUNDLE1BQU07WUFBQ0MsVUFBVUM7WUFBZUMsWUFBWUM7UUFBWTtJQUFDO0FBQ2xFLEVBQUM7QUFFRDs7O0NBR0MsR0FDRCxTQUFTRixjQUFjRyxPQUFPLEVBQUVsQixFQUFFLEVBQUVtQixHQUFHO0lBQ3JDLE1BQU1DLE9BQU8sSUFBSTtJQUNqQixJQUFJQyxPQUFPO0lBQ1gsSUFBSUMsUUFBUTtJQUNaLGdDQUFnQyxHQUNoQyxJQUFJQztJQUVKLE9BQU9DO0lBRVA7Ozs7Ozs7Ozs7Ozs7OztHQWVDLEdBQ0QsU0FBU0EsTUFBTUMsSUFBSTtRQUNqQixJQUFJQyxRQUFRTixLQUFLTyxNQUFNLENBQUNDLE1BQU0sR0FBRztRQUVqQyxNQUFPRixRQUFRLENBQUMsRUFBRztZQUNqQixNQUFNRyxPQUFPVCxLQUFLTyxNQUFNLENBQUNELE1BQU0sQ0FBQyxFQUFFLENBQUNHLElBQUk7WUFDdkMsSUFDRUEsU0FBU3JCLGlFQUFLQSxDQUFDc0IsVUFBVSxJQUN6Qiw4REFBOEQ7WUFDOURELFNBQVNyQixpRUFBS0EsQ0FBQ3VCLFVBQVUsRUFFekJMO2lCQUNHO1FBQ1A7UUFFQSxNQUFNTSxPQUFPTixRQUFRLENBQUMsSUFBSU4sS0FBS08sTUFBTSxDQUFDRCxNQUFNLENBQUMsRUFBRSxDQUFDRyxJQUFJLEdBQUc7UUFFdkQsTUFBTUksT0FDSkQsU0FBUyxlQUFlQSxTQUFTLGFBQWFFLGVBQWVDO1FBRS9ELDhCQUE4QjtRQUM5QixJQUFJRixTQUFTQyxnQkFBZ0JkLEtB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QztTQUFRO0lBQ3pDO0lBRUFrQyxNQUFNbEIsR0FBRyxHQUFHRixPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHc0I7SUFDOUJELE1BQU1FLElBQUksQ0FBQztRQUFDO1FBQVFKO1FBQU9sQztLQUFRO0lBRW5DVSxJQUFJTyxHQUFHLENBQUMvRCxRQUFRLEdBQUcsR0FBR2tGO0FBQ3hCO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNYLFNBQVN0RSxNQUFNLEVBQUVELEtBQUs7SUFDN0IsTUFBTXlELFFBQVF4RCxNQUFNLENBQUNELE1BQU07SUFDM0IsTUFBTXFGLE9BQU81QixLQUFLLENBQUMsRUFBRSxLQUFLLFVBQVUsVUFBVTtJQUM5QyxPQUFPQSxLQUFLLENBQUMsRUFBRSxDQUFDNEIsS0FBSztBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRwbGF0ZS8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWJsZS9kZXYvbGliL3N5bnRheC5qcz9mNDEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FdmVudH0gRXZlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXh0ZW5zaW9ufSBFeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUG9pbnR9IFBvaW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlJlc29sdmVyfSBSZXNvbHZlclxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5TdGF0ZX0gU3RhdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW59IFRva2VuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplQ29udGV4dH0gVG9rZW5pemVDb250ZXh0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7W251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl19IFJhbmdlXG4gKiAgIENlbGwgaW5mby5cbiAqXG4gKiBAdHlwZWRlZiB7MCB8IDEgfCAyIHwgM30gUm93S2luZFxuICogICBXaGVyZSB3ZSBhcmU6IGAxYCBmb3IgaGVhZCByb3csIGAyYCBmb3IgZGVsaW1pdGVyIHJvdywgYDNgIGZvciBib2R5IHJvdy5cbiAqL1xuXG5pbXBvcnQge29rIGFzIGFzc2VydH0gZnJvbSAndXZ1L2Fzc2VydCdcbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7XG4gIG1hcmtkb3duTGluZUVuZGluZyxcbiAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZSxcbiAgbWFya2Rvd25TcGFjZVxufSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5pbXBvcnQge2NvZGVzfSBmcm9tICdtaWNyb21hcmstdXRpbC1zeW1ib2wvY29kZXMuanMnXG5pbXBvcnQge2NvbnN0YW50c30gZnJvbSAnbWljcm9tYXJrLXV0aWwtc3ltYm9sL2NvbnN0YW50cy5qcydcbmltcG9ydCB7dHlwZXN9IGZyb20gJ21pY3JvbWFyay11dGlsLXN5bWJvbC90eXBlcy5qcydcbmltcG9ydCB7RWRpdE1hcH0gZnJvbSAnLi9lZGl0LW1hcC5qcydcbmltcG9ydCB7Z2ZtVGFibGVBbGlnbn0gZnJvbSAnLi9pbmZlci5qcydcblxuLy8gVG8gZG86IG5leHQgbWFqb3I6IGV4cG9zZSBmdW5jdGlvbnMuXG5cbi8qKlxuICogRXh0ZW5zaW9uIGZvciBgbWljcm9tYXJrYCB0aGF0IGNhbiBiZSBwYXNzZWQgaW4gYGV4dGVuc2lvbnNgIHRvIGVuYWJsZSBHRk1cbiAqIHRhYmxlIHN5bnRheC5cbiAqXG4gKiBAdHlwZSB7RXh0ZW5zaW9ufVxuICovXG5leHBvcnQgY29uc3QgZ2ZtVGFibGUgPSB7XG4gIGZsb3c6IHtudWxsOiB7dG9rZW5pemU6IHRva2VuaXplVGFibGUsIHJlc29sdmVBbGw6IHJlc29sdmVUYWJsZX19XG59XG5cbi8qKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplVGFibGUoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBsZXQgc2l6ZSA9IDBcbiAgbGV0IHNpemVCID0gMFxuICAvKiogQHR5cGUge2Jvb2xlYW4gfCB1bmRlZmluZWR9ICovXG4gIGxldCBzZWVuXG5cbiAgcmV0dXJuIHN0YXJ0XG5cbiAgLyoqXG4gICAqIFN0YXJ0IG9mIGEgR0ZNIHRhYmxlLlxuICAgKlxuICAgKiBJZiB0aGVyZSBpcyBhIHZhbGlkIHRhYmxlIHJvdyBvciB0YWJsZSBoZWFkIGJlZm9yZSwgdGhlbiB3ZSB0cnkgdG8gcGFyc2VcbiAgICogYW5vdGhlciByb3cuXG4gICAqIE90aGVyd2lzZSwgd2UgdHJ5IHRvIHBhcnNlIGEgaGVhZC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IHwgYSB8XG4gICAqICAgICBeXG4gICAqICAgfCB8IC0gfFxuICAgKiA+IHwgfCBiIHxcbiAgICogICAgIF5cbiAgICogYGBgXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBsZXQgaW5kZXggPSBzZWxmLmV2ZW50cy5sZW5ndGggLSAxXG5cbiAgICB3aGlsZSAoaW5kZXggPiAtMSkge1xuICAgICAgY29uc3QgdHlwZSA9IHNlbGYuZXZlbnRzW2luZGV4XVsxXS50eXBlXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGUgPT09IHR5cGVzLmxpbmVFbmRpbmcgfHxcbiAgICAgICAgLy8gTm90ZTogbWFya2Rvd24tcnMgdXNlcyBgd2hpdGVzcGFjZWAgaW5zdGVhZCBvZiBgbGluZVByZWZpeGBcbiAgICAgICAgdHlwZSA9PT0gdHlwZXMubGluZVByZWZpeFxuICAgICAgKVxuICAgICAgICBpbmRleC0tXG4gICAgICBlbHNlIGJyZWFrXG4gICAgfVxuXG4gICAgY29uc3QgdGFpbCA9IGluZGV4ID4gLTEgPyBzZWxmLmV2ZW50c1tpbmRleF1bMV0udHlwZSA6IG51bGxcblxuICAgIGNvbnN0IG5leHQgPVxuICAgICAgdGFpbCA9PT0gJ3RhYmxlSGVhZCcgfHwgdGFpbCA9PT0gJ3RhYmxlUm93JyA/IGJvZHlSb3dTdGFydCA6IGhlYWRSb3dCZWZvcmVcblxuICAgIC8vIERvbuKAmXQgYWxsb3cgbGF6eSBib2R5IHJvd3MuXG4gICAgaWYgKG5leHQgPT09IGJvZHlSb3dTdGFydCAmJiBzZWxmLnBhcnNlci5sYXp5W3NlbGYubm93KCkubGluZV0pIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dChjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEJlZm9yZSB0YWJsZSBoZWFkIHJvdy5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IHwgYSB8XG4gICAqICAgICBeXG4gICAqICAgfCB8IC0gfFxuICAgKiAgIHwgfCBiIHxcbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGhlYWRSb3dCZWZvcmUoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlSGVhZCcpXG4gICAgZWZmZWN0cy5lbnRlcigndGFibGVSb3cnKVxuICAgIHJldHVybiBoZWFkUm93U3RhcnQoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBCZWZvcmUgdGFibGUgaGVhZCByb3csIGFmdGVyIHdoaXRlc3BhY2UuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCB8IGEgfFxuICAgKiAgICAgXlxuICAgKiAgIHwgfCAtIHxcbiAgICogICB8IHwgYiB8XG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkUm93U3RhcnQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhcikge1xuICAgICAgcmV0dXJuIGhlYWRSb3dCcmVhayhjb2RlKVxuICAgIH1cblxuICAgIC8vIFRvIGRvOiBtaWNyb21hcmstanMgc2hvdWxkIGxldCB1cyBwYXJzZSBvdXIgb3duIHdoaXRlc3BhY2UgaW4gZXh0ZW5zaW9ucyxcbiAgICAvLyBsaWtlIGBtYXJrZG93bi1yc2A6XG4gICAgLy9cbiAgICAvLyBgYGBqc1xuICAgIC8vIC8vIDQrIHNwYWNlcy5cbiAgICAvLyBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgIC8vICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIC8vIH1cbiAgICAvLyBgYGBcblxuICAgIHNlZW4gPSB0cnVlXG4gICAgLy8gQ291bnQgdGhlIGZpcnN0IGNoYXJhY3RlciwgdGhhdCBpc27igJl0IGEgcGlwZSwgZG91YmxlLlxuICAgIHNpemVCICs9IDFcbiAgICByZXR1cm4gaGVhZFJvd0JyZWFrKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQXQgYnJlYWsgaW4gdGFibGUgaGVhZCByb3cuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCB8IGEgfFxuICAgKiAgICAgXlxuICAgKiAgICAgICBeXG4gICAqICAgICAgICAgXlxuICAgKiAgIHwgfCAtIHxcbiAgICogICB8IHwgYiB8XG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkUm93QnJlYWsoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBjb2Rlcy5lb2YpIHtcbiAgICAgIC8vIE5vdGU6IGluIGBtYXJrZG93bi1yc2AsIHdlIG5lZWQgdG8gcmVzZXQsIGluIGBtaWNyb21hcmstanNgIHdlIGRvbuKAmHQuXG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgLy8gSWYgYW55dGhpbmcgb3RoZXIgdGhhbiBvbmUgcGlwZSAoaWdub3Jpbmcgd2hpdGVzcGFjZSkgd2FzIHVzZWQsIGl04oCZcyBmaW5lLlxuICAgICAgaWYgKHNpemVCID4gMSkge1xuICAgICAgICBzaXplQiA9IDBcbiAgICAgICAgLy8gVG8gZG86IGNoZWNrIGlmIHRoaXMgd29ya3MuXG4gICAgICAgIC8vIEZlZWwgZnJlZSB0byBpbnRlcnJ1cHQ6XG4gICAgICAgIHNlbGYuaW50ZXJydXB0ID0gdHJ1ZVxuICAgICAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlUm93JylcbiAgICAgICAgZWZmZWN0cy5lbnRlcih0eXBlcy5saW5lRW5kaW5nKVxuICAgICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgICAgZWZmZWN0cy5leGl0KHR5cGVzLmxpbmVFbmRpbmcpXG4gICAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyU3RhcnRcbiAgICAgIH1cblxuICAgICAgLy8gTm90ZTogaW4gYG1hcmtkb3duLXJzYCwgd2UgbmVlZCB0byByZXNldCwgaW4gYG1pY3JvbWFyay1qc2Agd2UgZG9u4oCYdC5cbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgLy8gVG8gZG86IGNoZWNrIGlmIHRoaXMgaXMgZmluZS5cbiAgICAgIC8vIGVmZmVjdHMuYXR0ZW1wdChTdGF0ZTo6TmV4dChTdGF0ZU5hbWU6OkdmbVRhYmxlSGVhZFJvd0JyZWFrKSwgU3RhdGU6Ok5vaylcbiAgICAgIC8vIFN0YXRlOjpSZXRyeShzcGFjZV9vcl90YWIodG9rZW5pemVyKSlcbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgaGVhZFJvd0JyZWFrLCB0eXBlcy53aGl0ZXNwYWNlKShjb2RlKVxuICAgIH1cblxuICAgIHNpemVCICs9IDFcblxuICAgIGlmIChzZWVuKSB7XG4gICAgICBzZWVuID0gZmFsc2VcbiAgICAgIC8vIEhlYWRlciBjZWxsIGNvdW50LlxuICAgICAgc2l6ZSArPSAxXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLnZlcnRpY2FsQmFyKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICAgIC8vIFdoZXRoZXIgYSBkZWxpbWl0ZXIgd2FzIHNlZW4uXG4gICAgICBzZWVuID0gdHJ1ZVxuICAgICAgcmV0dXJuIGhlYWRSb3dCcmVha1xuICAgIH1cblxuICAgIC8vIEFueXRoaW5nIGVsc2UgaXMgY2VsbCBkYXRhLlxuICAgIGVmZmVjdHMuZW50ZXIodHlwZXMuZGF0YSlcbiAgICByZXR1cm4gaGVhZFJvd0RhdGEoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiB0YWJsZSBoZWFkIHJvdyBkYXRhLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgfCBhIHxcbiAgICogICAgICAgXlxuICAgKiAgIHwgfCAtIHxcbiAgICogICB8IHwgYiB8XG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkUm93RGF0YShjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gY29kZXMuZW9mIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhciB8fFxuICAgICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKVxuICAgICkge1xuICAgICAgZWZmZWN0cy5leGl0KHR5cGVzLmRhdGEpXG4gICAgICByZXR1cm4gaGVhZFJvd0JyZWFrKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNvZGUgPT09IGNvZGVzLmJhY2tzbGFzaCA/IGhlYWRSb3dFc2NhcGUgOiBoZWFkUm93RGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHRhYmxlIGhlYWQgcm93IGVzY2FwZS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IHwgYVxcLWIgfFxuICAgKiAgICAgICAgIF5cbiAgICogICB8IHwgLS0tLSB8XG4gICAqICAgfCB8IGMgICAgfFxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZFJvd0VzY2FwZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmJhY2tzbGFzaCB8fCBjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhcikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaGVhZFJvd0RhdGFcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZFJvd0RhdGEoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBCZWZvcmUgZGVsaW1pdGVyIHJvdy5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8IHwgYSB8XG4gICAqID4gfCB8IC0gfFxuICAgKiAgICAgXlxuICAgKiAgIHwgfCBiIHxcbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGhlYWREZWxpbWl0ZXJTdGFydChjb2RlKSB7XG4gICAgLy8gUmVzZXQgYGludGVycnVwdGAuXG4gICAgc2VsZi5pbnRlcnJ1cHQgPSBmYWxzZVxuXG4gICAgLy8gTm90ZTogaW4gYG1hcmtkb3duLXJzYCwgd2UgbmVlZCB0byBoYW5kbGUgcGllcmNpbmcgaGVyZSB0b28uXG4gICAgaWYgKHNlbGYucGFyc2VyLmxhenlbc2VsZi5ub3coKS5saW5lXSkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlRGVsaW1pdGVyUm93JylcbiAgICAvLyBUcmFjayBpZiB3ZeKAmXZlIHNlZW4gYSBgOmAgb3IgYHxgLlxuICAgIHNlZW4gPSBmYWxzZVxuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIGFzc2VydChzZWxmLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbCwgJ2V4cGVjdGVkIGBkaXNhYmxlZC5udWxsYCcpXG4gICAgICByZXR1cm4gZmFjdG9yeVNwYWNlKFxuICAgICAgICBlZmZlY3RzLFxuICAgICAgICBoZWFkRGVsaW1pdGVyQmVmb3JlLFxuICAgICAgICB0eXBlcy5saW5lUHJlZml4LFxuICAgICAgICBzZWxmLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbC5pbmNsdWRlcygnY29kZUluZGVudGVkJylcbiAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgIDogY29uc3RhbnRzLnRhYlNpemVcbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZERlbGltaXRlckJlZm9yZShjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEJlZm9yZSBkZWxpbWl0ZXIgcm93LCBhZnRlciBvcHRpb25hbCB3aGl0ZXNwYWNlLlxuICAgKlxuICAgKiBSZXVzZWQgd2hlbiBhIGB8YCBpcyBmb3VuZCBsYXRlciwgdG8gcGFyc2UgYW5vdGhlciBjZWxsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCBhIHxcbiAgICogPiB8IHwgLSB8XG4gICAqICAgICBeXG4gICAqICAgfCB8IGIgfFxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZERlbGltaXRlckJlZm9yZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmRhc2ggfHwgY29kZSA9PT0gY29kZXMuY29sb24pIHtcbiAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyVmFsdWVCZWZvcmUoY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMudmVydGljYWxCYXIpIHtcbiAgICAgIHNlZW4gPSB0cnVlXG4gICAgICAvLyBJZiB3ZSBzdGFydCB3aXRoIGEgcGlwZSwgd2Ugb3BlbiBhIGNlbGwgbWFya2VyLlxuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVDZWxsRGl2aWRlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVDZWxsRGl2aWRlcicpXG4gICAgICByZXR1cm4gaGVhZERlbGltaXRlckNlbGxCZWZvcmVcbiAgICB9XG5cbiAgICAvLyBNb3JlIHdoaXRlc3BhY2UgLyBlbXB0eSByb3cgbm90IGFsbG93ZWQgYXQgc3RhcnQuXG4gICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJOb2soY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBgfGAsIGJlZm9yZSBkZWxpbWl0ZXIgY2VsbC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8IHwgYSB8XG4gICAqID4gfCB8IC0gfFxuICAgKiAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGhlYWREZWxpbWl0ZXJDZWxsQmVmb3JlKGNvZGUpIHtcbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgcmV0dXJuIGZhY3RvcnlTcGFjZShcbiAgICAgICAgZWZmZWN0cyxcbiAgICAgICAgaGVhZERlbGltaXRlclZhbHVlQmVmb3JlLFxuICAgICAgICB0eXBlcy53aGl0ZXNwYWNlXG4gICAgICApKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJWYWx1ZUJlZm9yZShjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEJlZm9yZSBkZWxpbWl0ZXIgY2VsbCB2YWx1ZS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8IHwgYSB8XG4gICAqID4gfCB8IC0gfFxuICAgKiAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkRGVsaW1pdGVyVmFsdWVCZWZvcmUoY29kZSkge1xuICAgIC8vIEFsaWduOiBsZWZ0LlxuICAgIGlmIChjb2RlID09PSBjb2Rlcy5jb2xvbikge1xuICAgICAgc2l6ZUIgKz0gMVxuICAgICAgc2VlbiA9IHRydWVcblxuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVEZWxpbWl0ZXJNYXJrZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlRGVsaW1pdGVyTWFya2VyJylcbiAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyTGVmdEFsaWdubWVudEFmdGVyXG4gICAgfVxuXG4gICAgLy8gQWxpZ246IG5vbmUuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmRhc2gpIHtcbiAgICAgIHNpemVCICs9IDFcbiAgICAgIC8vIFRvIGRvOiBzZWVtcyB3ZWlyZCB0aGF0IHRoaXMgKmlzbuKAmXQqIGxlZnQgYWxpZ25lZCwgYnV0IHRoYXQgc3RhdGUgaXMgdXNlZD9cbiAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyTGVmdEFsaWdubWVudEFmdGVyKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmVvZiB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyQ2VsbEFmdGVyKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJOb2soY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBkZWxpbWl0ZXIgY2VsbCBsZWZ0IGFsaWdubWVudCBtYXJrZXIuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCB8IGEgIHxcbiAgICogPiB8IHwgOi0gfFxuICAgKiAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZERlbGltaXRlckxlZnRBbGlnbm1lbnRBZnRlcihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmRhc2gpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlRGVsaW1pdGVyRmlsbGVyJylcbiAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyRmlsbGVyKGNvZGUpXG4gICAgfVxuXG4gICAgLy8gQW55dGhpbmcgZWxzZSBpcyBub3Qgb2sgYWZ0ZXIgdGhlIGxlZnQtYWxpZ24gY29sb24uXG4gICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJOb2soY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBkZWxpbWl0ZXIgY2VsbCBmaWxsZXIuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCB8IGEgfFxuICAgKiA+IHwgfCAtIHxcbiAgICogICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZERlbGltaXRlckZpbGxlcihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmRhc2gpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJGaWxsZXJcbiAgICB9XG5cbiAgICAvLyBBbGlnbiBpcyBgY2VudGVyYCBpZiBpdCB3YXMgYGxlZnRgLCBgcmlnaHRgIG90aGVyd2lzZS5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMuY29sb24pIHtcbiAgICAgIHNlZW4gPSB0cnVlXG4gICAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlRGVsaW1pdGVyRmlsbGVyJylcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlRGVsaW1pdGVyTWFya2VyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZURlbGltaXRlck1hcmtlcicpXG4gICAgICByZXR1cm4gaGVhZERlbGltaXRlclJpZ2h0QWxpZ25tZW50QWZ0ZXJcbiAgICB9XG5cbiAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlRGVsaW1pdGVyRmlsbGVyJylcbiAgICByZXR1cm4gaGVhZERlbGltaXRlclJpZ2h0QWxpZ25tZW50QWZ0ZXIoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBkZWxpbWl0ZXIgY2VsbCByaWdodCBhbGlnbm1lbnQgbWFya2VyLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCAgYSB8XG4gICAqID4gfCB8IC06IHxcbiAgICogICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkRGVsaW1pdGVyUmlnaHRBbGlnbm1lbnRBZnRlcihjb2RlKSB7XG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIGhlYWREZWxpbWl0ZXJDZWxsQWZ0ZXIsXG4gICAgICAgIHR5cGVzLndoaXRlc3BhY2VcbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZERlbGltaXRlckNlbGxBZnRlcihjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIGRlbGltaXRlciBjZWxsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCAgYSB8XG4gICAqID4gfCB8IC06IHxcbiAgICogICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZERlbGltaXRlckNlbGxBZnRlcihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLnZlcnRpY2FsQmFyKSB7XG4gICAgICByZXR1cm4gaGVhZERlbGltaXRlckJlZm9yZShjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBjb2Rlcy5lb2YgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICAvLyBFeGl0IHdoZW46XG4gICAgICAvLyAqIHRoZXJlIHdhcyBubyBgOmAgb3IgYHxgIGF0IGFsbCAoaXTigJlzIGEgdGhlbWF0aWMgYnJlYWsgb3Igc2V0ZXh0XG4gICAgICAvLyAgIHVuZGVybGluZSBpbnN0ZWFkKVxuICAgICAgLy8gKiB0aGUgaGVhZGVyIGNlbGwgY291bnQgaXMgbm90IHRoZSBkZWxpbWl0ZXIgY2VsbCBjb3VudFxuICAgICAgaWYgKCFzZWVuIHx8IHNpemUgIT09IHNpemVCKSB7XG4gICAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyTm9rKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIC8vIE5vdGU6IGluIG1hcmtkb3duLXJzYCwgYSByZXNldCBpcyBuZWVkZWQgaGVyZS5cbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVEZWxpbWl0ZXJSb3cnKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZUhlYWQnKVxuICAgICAgLy8gVG8gZG86IGluIGBtYXJrZG93bi1yc2AsIHJlc29sdmVycyBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgbWFudWFsbHkuXG4gICAgICAvLyBlZmZlY3RzLnJlZ2lzdGVyX3Jlc29sdmVyKFJlc29sdmVOYW1lOjpHZm1UYWJsZSlcbiAgICAgIHJldHVybiBvayhjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBoZWFkRGVsaW1pdGVyTm9rKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogSW4gZGVsaW1pdGVyIHJvdywgYXQgYSBkaXNhbGxvd2VkIGJ5dGUuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCB8IGEgfFxuICAgKiA+IHwgfCB4IHxcbiAgICogICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZERlbGltaXRlck5vayhjb2RlKSB7XG4gICAgLy8gTm90ZTogaW4gYG1hcmtkb3duLXJzYCwgd2UgbmVlZCB0byByZXNldCwgaW4gYG1pY3JvbWFyay1qc2Agd2UgZG9u4oCYdC5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQmVmb3JlIHRhYmxlIGJvZHkgcm93LlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCBhIHxcbiAgICogICB8IHwgLSB8XG4gICAqID4gfCB8IGIgfFxuICAgKiAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gYm9keVJvd1N0YXJ0KGNvZGUpIHtcbiAgICAvLyBOb3RlOiBpbiBgbWFya2Rvd24tcnNgIHdlIG5lZWQgdG8gbWFudWFsbHkgdGFrZSBjYXJlIG9mIGEgcHJlZml4LFxuICAgIC8vIGJ1dCBpbiBgbWljcm9tYXJrLWpzYCB0aGF0IGlzIGRvbmUgZm9yIHVzLCBzbyBpZiB3ZeKAmXJlIGhlcmUsIHdl4oCZcmVcbiAgICAvLyBuZXZlciBhdCB3aGl0ZXNwYWNlLlxuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlUm93JylcbiAgICByZXR1cm4gYm9keVJvd0JyZWFrKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQXQgYnJlYWsgaW4gdGFibGUgYm9keSByb3cuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCB8IGEgfFxuICAgKiAgIHwgfCAtIHxcbiAgICogPiB8IHwgYiB8XG4gICAqICAgICBeXG4gICAqICAgICAgIF5cbiAgICogICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBib2R5Um93QnJlYWsoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhcikge1xuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVDZWxsRGl2aWRlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVDZWxsRGl2aWRlcicpXG4gICAgICByZXR1cm4gYm9keVJvd0JyZWFrXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmVvZiB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVSb3cnKVxuICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgYm9keVJvd0JyZWFrLCB0eXBlcy53aGl0ZXNwYWNlKShjb2RlKVxuICAgIH1cblxuICAgIC8vIEFueXRoaW5nIGVsc2UgaXMgY2VsbCBjb250ZW50LlxuICAgIGVmZmVjdHMuZW50ZXIodHlwZXMuZGF0YSlcbiAgICByZXR1cm4gYm9keVJvd0RhdGEoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiB0YWJsZSBib2R5IHJvdyBkYXRhLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCBhIHxcbiAgICogICB8IHwgLSB8XG4gICAqID4gfCB8IGIgfFxuICAgKiAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBib2R5Um93RGF0YShjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gY29kZXMuZW9mIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhciB8fFxuICAgICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKVxuICAgICkge1xuICAgICAgZWZmZWN0cy5leGl0KHR5cGVzLmRhdGEpXG4gICAgICByZXR1cm4gYm9keVJvd0JyZWFrKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNvZGUgPT09IGNvZGVzLmJhY2tzbGFzaCA/IGJvZHlSb3dFc2NhcGUgOiBib2R5Um93RGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHRhYmxlIGJvZHkgcm93IGVzY2FwZS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8IHwgYSAgICB8XG4gICAqICAgfCB8IC0tLS0gfFxuICAgKiA+IHwgfCBiXFwtYyB8XG4gICAqICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gYm9keVJvd0VzY2FwZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmJhY2tzbGFzaCB8fCBjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhcikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gYm9keVJvd0RhdGFcbiAgICB9XG5cbiAgICByZXR1cm4gYm9keVJvd0RhdGEoY29kZSlcbiAgfVxufVxuXG4vKiogQHR5cGUge1Jlc29sdmVyfSAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHJlc29sdmVUYWJsZShldmVudHMsIGNvbnRleHQpIHtcbiAgbGV0IGluZGV4ID0gLTFcbiAgbGV0IGluRmlyc3RDZWxsQXdhaXRpbmdQaXBlID0gdHJ1ZVxuICAvKiogQHR5cGUge1Jvd0tpbmR9ICovXG4gIGxldCByb3dLaW5kID0gMFxuICAvKiogQHR5cGUge1JhbmdlfSAqL1xuICBsZXQgbGFzdENlbGwgPSBbMCwgMCwgMCwgMF1cbiAgLyoqIEB0eXBlIHtSYW5nZX0gKi9cbiAgbGV0IGNlbGwgPSBbMCwgMCwgMCwgMF1cbiAgbGV0IGFmdGVySGVhZEF3YWl0aW5nRmlyc3RCb2R5Um93ID0gZmFsc2VcbiAgbGV0IGxhc3RUYWJsZUVuZCA9IDBcbiAgLyoqIEB0eXBlIHtUb2tlbiB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IGN1cnJlbnRUYWJsZVxuICAvKiogQHR5cGUge1Rva2VuIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgY3VycmVudEJvZHlcbiAgLyoqIEB0eXBlIHtUb2tlbiB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IGN1cnJlbnRDZWxsXG5cbiAgY29uc3QgbWFwID0gbmV3IEVkaXRNYXAoKVxuXG4gIHdoaWxlICgrK2luZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzW2luZGV4XVxuICAgIGNvbnN0IHRva2VuID0gZXZlbnRbMV1cblxuICAgIGlmIChldmVudFswXSA9PT0gJ2VudGVyJykge1xuICAgICAgLy8gU3RhcnQgb2YgaGVhZC5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSAndGFibGVIZWFkJykge1xuICAgICAgICBhZnRlckhlYWRBd2FpdGluZ0ZpcnN0Qm9keVJvdyA9IGZhbHNlXG5cbiAgICAgICAgLy8gSW5qZWN0IHByZXZpb3VzIChib2R5IGVuZCBhbmQpIHRhYmxlIGVuZC5cbiAgICAgICAgaWYgKGxhc3RUYWJsZUVuZCAhPT0gMCkge1xuICAgICAgICAgIGFzc2VydChjdXJyZW50VGFibGUsICd0aGVyZSBzaG91bGQgYmUgYSB0YWJsZSBvcGVuaW5nJylcbiAgICAgICAgICBmbHVzaFRhYmxlRW5kKG1hcCwgY29udGV4dCwgbGFzdFRhYmxlRW5kLCBjdXJyZW50VGFibGUsIGN1cnJlbnRCb2R5KVxuICAgICAgICAgIGN1cnJlbnRCb2R5ID0gdW5kZWZpbmVkXG4gICAgICAgICAgbGFzdFRhYmxlRW5kID0gMFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5qZWN0IHRhYmxlIHN0YXJ0LlxuICAgICAgICBjdXJyZW50VGFibGUgPSB7XG4gICAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgdG9rZW4uc3RhcnQpLFxuICAgICAgICAgIC8vIE5vdGU6IGNvcnJlY3QgZW5kIGlzIHNldCBsYXRlci5cbiAgICAgICAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIHRva2VuLmVuZClcbiAgICAgICAgfVxuICAgICAgICBtYXAuYWRkKGluZGV4LCAwLCBbWydlbnRlcicsIGN1cnJlbnRUYWJsZSwgY29udGV4dF1dKVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gJ3RhYmxlUm93JyB8fFxuICAgICAgICB0b2tlbi50eXBlID09PSAndGFibGVEZWxpbWl0ZXJSb3cnXG4gICAgICApIHtcbiAgICAgICAgaW5GaXJzdENlbGxBd2FpdGluZ1BpcGUgPSB0cnVlXG4gICAgICAgIGN1cnJlbnRDZWxsID0gdW5kZWZpbmVkXG4gICAgICAgIGxhc3RDZWxsID0gWzAsIDAsIDAsIDBdXG4gICAgICAgIGNlbGwgPSBbMCwgaW5kZXggKyAxLCAwLCAwXVxuXG4gICAgICAgIC8vIEluamVjdCB0YWJsZSBib2R5IHN0YXJ0LlxuICAgICAgICBpZiAoYWZ0ZXJIZWFkQXdhaXRpbmdGaXJzdEJvZHlSb3cpIHtcbiAgICAgICAgICBhZnRlckhlYWRBd2FpdGluZ0ZpcnN0Qm9keVJvdyA9IGZhbHNlXG4gICAgICAgICAgY3VycmVudEJvZHkgPSB7XG4gICAgICAgICAgICB0eXBlOiAndGFibGVCb2R5JyxcbiAgICAgICAgICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCB0b2tlbi5zdGFydCksXG4gICAgICAgICAgICAvLyBOb3RlOiBjb3JyZWN0IGVuZCBpcyBzZXQgbGF0ZXIuXG4gICAgICAgICAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIHRva2VuLmVuZClcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwLmFkZChpbmRleCwgMCwgW1snZW50ZXInLCBjdXJyZW50Qm9keSwgY29udGV4dF1dKVxuICAgICAgICB9XG5cbiAgICAgICAgcm93S2luZCA9IHRva2VuLnR5cGUgPT09ICd0YWJsZURlbGltaXRlclJvdycgPyAyIDogY3VycmVudEJvZHkgPyAzIDogMVxuICAgICAgfVxuICAgICAgLy8gQ2VsbCBkYXRhLlxuICAgICAgZWxzZSBpZiAoXG4gICAgICAgIHJvd0tpbmQgJiZcbiAgICAgICAgKHRva2VuLnR5cGUgPT09IHR5cGVzLmRhdGEgfHxcbiAgICAgICAgICB0b2tlbi50eXBlID09PSAndGFibGVEZWxpbWl0ZXJNYXJrZXInIHx8XG4gICAgICAgICAgdG9rZW4udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyRmlsbGVyJylcbiAgICAgICkge1xuICAgICAgICBpbkZpcnN0Q2VsbEF3YWl0aW5nUGlwZSA9IGZhbHNlXG5cbiAgICAgICAgLy8gRmlyc3QgdmFsdWUgaW4gY2VsbC5cbiAgICAgICAgaWYgKGNlbGxbMl0gPT09IDApIHtcbiAgICAgICAgICBpZiAobGFzdENlbGxbMV0gIT09IDApIHtcbiAgICAgICAgICAgIGNlbGxbMF0gPSBjZWxsWzFdXG4gICAgICAgICAgICBjdXJyZW50Q2VsbCA9IGZsdXNoQ2VsbChcbiAgICAgICAgICAgICAgbWFwLFxuICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICBsYXN0Q2VsbCxcbiAgICAgICAgICAgICAgcm93S2luZCxcbiAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBjdXJyZW50Q2VsbFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgbGFzdENlbGwgPSBbMCwgMCwgMCwgMF1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjZWxsWzJdID0gaW5kZXhcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSAndGFibGVDZWxsRGl2aWRlcicpIHtcbiAgICAgICAgaWYgKGluRmlyc3RDZWxsQXdhaXRpbmdQaXBlKSB7XG4gICAgICAgICAgaW5GaXJzdENlbGxBd2FpdGluZ1BpcGUgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChsYXN0Q2VsbFsxXSAhPT0gMCkge1xuICAgICAgICAgICAgY2VsbFswXSA9IGNlbGxbMV1cbiAgICAgICAgICAgIGN1cnJlbnRDZWxsID0gZmx1c2hDZWxsKFxuICAgICAgICAgICAgICBtYXAsXG4gICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgIGxhc3RDZWxsLFxuICAgICAgICAgICAgICByb3dLaW5kLFxuICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGN1cnJlbnRDZWxsXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGFzdENlbGwgPSBjZWxsXG4gICAgICAgICAgY2VsbCA9IFtsYXN0Q2VsbFsxXSwgaW5kZXgsIDAsIDBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRXhpdCBldmVudHMuXG4gICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gJ3RhYmxlSGVhZCcpIHtcbiAgICAgIGFmdGVySGVhZEF3YWl0aW5nRmlyc3RCb2R5Um93ID0gdHJ1ZVxuICAgICAgbGFzdFRhYmxlRW5kID0gaW5kZXhcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdG9rZW4udHlwZSA9PT0gJ3RhYmxlUm93JyB8fFxuICAgICAgdG9rZW4udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyUm93J1xuICAgICkge1xuICAgICAgbGFzdFRhYmxlRW5kID0gaW5kZXhcblxuICAgICAgaWYgKGxhc3RDZWxsWzFdICE9PSAwKSB7XG4gICAgICAgIGNlbGxbMF0gPSBjZWxsWzFdXG4gICAgICAgIGN1cnJlbnRDZWxsID0gZmx1c2hDZWxsKFxuICAgICAgICAgIG1hcCxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIGxhc3RDZWxsLFxuICAgICAgICAgIHJvd0tpbmQsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgY3VycmVudENlbGxcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIGlmIChjZWxsWzFdICE9PSAwKSB7XG4gICAgICAgIGN1cnJlbnRDZWxsID0gZmx1c2hDZWxsKG1hcCwgY29udGV4dCwgY2VsbCwgcm93S2luZCwgaW5kZXgsIGN1cnJlbnRDZWxsKVxuICAgICAgfVxuXG4gICAgICByb3dLaW5kID0gMFxuICAgIH0gZWxzZSBpZiAoXG4gICAgICByb3dLaW5kICYmXG4gICAgICAodG9rZW4udHlwZSA9PT0gdHlwZXMuZGF0YSB8fFxuICAgICAgICB0b2tlbi50eXBlID09PSAndGFibGVEZWxpbWl0ZXJNYXJrZXInIHx8XG4gICAgICAgIHRva2VuLnR5cGUgPT09ICd0YWJsZURlbGltaXRlckZpbGxlcicpXG4gICAgKSB7XG4gICAgICBjZWxsWzNdID0gaW5kZXhcbiAgICB9XG4gIH1cblxuICBpZiAobGFzdFRhYmxlRW5kICE9PSAwKSB7XG4gICAgYXNzZXJ0KGN1cnJlbnRUYWJsZSwgJ2V4cGVjdGVkIHRhYmxlIG9wZW5pbmcnKVxuICAgIGZsdXNoVGFibGVFbmQobWFwLCBjb250ZXh0LCBsYXN0VGFibGVFbmQsIGN1cnJlbnRUYWJsZSwgY3VycmVudEJvZHkpXG4gIH1cblxuICBtYXAuY29uc3VtZShjb250ZXh0LmV2ZW50cylcblxuICAvLyBUbyBkbzogbW92ZSB0aGlzIGludG8gYGh0bWxgLCB3aGVuIGV2ZW50cyBhcmUgZXhwb3NlZCB0aGVyZS5cbiAgLy8gVGhhdOKAmXMgd2hhdCBgbWFya2Rvd24tcnNgIGRvZXMuXG4gIC8vIFRoYXQgbmVlZHMgdXBkYXRlcyB0byBgbWRhc3QtdXRpbC1nZm0tdGFibGVgLlxuICBpbmRleCA9IC0xXG4gIHdoaWxlICgrK2luZGV4IDwgY29udGV4dC5ldmVudHMubGVuZ3RoKSB7XG4gICAgY29uc3QgZXZlbnQgPSBjb250ZXh0LmV2ZW50c1tpbmRleF1cbiAgICBpZiAoZXZlbnRbMF0gPT09ICdlbnRlcicgJiYgZXZlbnRbMV0udHlwZSA9PT0gJ3RhYmxlJykge1xuICAgICAgZXZlbnRbMV0uX2FsaWduID0gZ2ZtVGFibGVBbGlnbihjb250ZXh0LmV2ZW50cywgaW5kZXgpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50c1xufVxuXG4vLy8gR2VuZXJhdGUgYSBjZWxsLlxuLyoqXG4gKlxuICogQHBhcmFtIHtFZGl0TWFwfSBtYXBcbiAqIEBwYXJhbSB7VG9rZW5pemVDb250ZXh0fSBjb250ZXh0XG4gKiBAcGFyYW0ge1JhbmdlfSByYW5nZVxuICogQHBhcmFtIHtSb3dLaW5kfSByb3dLaW5kXG4gKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gcm93RW5kXG4gKiBAcGFyYW0ge1Rva2VuIHwgdW5kZWZpbmVkfSBwcmV2aW91c0NlbGxcbiAqIEByZXR1cm5zIHtUb2tlbiB8IHVuZGVmaW5lZH1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbmZ1bmN0aW9uIGZsdXNoQ2VsbChtYXAsIGNvbnRleHQsIHJhbmdlLCByb3dLaW5kLCByb3dFbmQsIHByZXZpb3VzQ2VsbCkge1xuICAvLyBgbWFya2Rvd24tcnNgIHVzZXM6XG4gIC8vIHJvd0tpbmQgPT09IDIgPyAndGFibGVEZWxpbWl0ZXJDZWxsJyA6ICd0YWJsZUNlbGwnXG4gIGNvbnN0IGdyb3VwTmFtZSA9XG4gICAgcm93S2luZCA9PT0gMVxuICAgICAgPyAndGFibGVIZWFkZXInXG4gICAgICA6IHJvd0tpbmQgPT09IDJcbiAgICAgID8gJ3RhYmxlRGVsaW1pdGVyJ1xuICAgICAgOiAndGFibGVEYXRhJ1xuICAvLyBgbWFya2Rvd24tcnNgIHVzZXM6XG4gIC8vIHJvd0tpbmQgPT09IDIgPyAndGFibGVEZWxpbWl0ZXJDZWxsVmFsdWUnIDogJ3RhYmxlQ2VsbFRleHQnXG4gIGNvbnN0IHZhbHVlTmFtZSA9ICd0YWJsZUNvbnRlbnQnXG5cbiAgLy8gSW5zZXJ0IGFuIGV4aXQgZm9yIHRoZSBwcmV2aW91cyBjZWxsLCBpZiB0aGVyZSBpcyBvbmUuXG4gIC8vXG4gIC8vIGBgYG1hcmtkb3duXG4gIC8vID4gfCB8IGFhIHwgYmIgfCBjYyB8XG4gIC8vICAgICAgICAgIF4tLSBleGl0XG4gIC8vICAgICAgICAgICBeXl5eLS0gdGhpcyBjZWxsXG4gIC8vIGBgYFxuICBpZiAocmFuZ2VbMF0gIT09IDApIHtcbiAgICBhc3NlcnQocHJldmlvdXNDZWxsLCAnZXhwZWN0ZWQgcHJldmlvdXMgY2VsbCBlbnRlcicpXG4gICAgcHJldmlvdXNDZWxsLmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIGdldFBvaW50KGNvbnRleHQuZXZlbnRzLCByYW5nZVswXSkpXG4gICAgbWFwLmFkZChyYW5nZVswXSwgMCwgW1snZXhpdCcsIHByZXZpb3VzQ2VsbCwgY29udGV4dF1dKVxuICB9XG5cbiAgLy8gSW5zZXJ0IGVudGVyIG9mIHRoaXMgY2VsbC5cbiAgLy9cbiAgLy8gYGBgbWFya2Rvd25cbiAgLy8gPiB8IHwgYWEgfCBiYiB8IGNjIHxcbiAgLy8gICAgICAgICAgIF4tLSBlbnRlclxuICAvLyAgICAgICAgICAgXl5eXi0tIHRoaXMgY2VsbFxuICAvLyBgYGBcbiAgY29uc3Qgbm93ID0gZ2V0UG9pbnQoY29udGV4dC5ldmVudHMsIHJhbmdlWzFdKVxuICBwcmV2aW91c0NlbGwgPSB7XG4gICAgdHlwZTogZ3JvdXBOYW1lLFxuICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBub3cpLFxuICAgIC8vIE5vdGU6IGNvcnJlY3QgZW5kIGlzIHNldCBsYXRlci5cbiAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIG5vdylcbiAgfVxuICBtYXAuYWRkKHJhbmdlWzFdLCAwLCBbWydlbnRlcicsIHByZXZpb3VzQ2VsbCwgY29udGV4dF1dKVxuXG4gIC8vIEluc2VydCB0ZXh0IHN0YXJ0IGF0IGZpcnN0IGRhdGEgc3RhcnQgYW5kIGVuZCBhdCBsYXN0IGRhdGEgZW5kLCBhbmRcbiAgLy8gcmVtb3ZlIGV2ZW50cyBiZXR3ZWVuLlxuICAvL1xuICAvLyBgYGBtYXJrZG93blxuICAvLyA+IHwgfCBhYSB8IGJiIHwgY2MgfFxuICAvLyAgICAgICAgICAgIF4tLSBlbnRlclxuICAvLyAgICAgICAgICAgICBeLS0gZXhpdFxuICAvLyAgICAgICAgICAgXl5eXi0tIHRoaXMgY2VsbFxuICAvLyBgYGBcbiAgaWYgKHJhbmdlWzJdICE9PSAwKSB7XG4gICAgY29uc3QgcmVsYXRlZFN0YXJ0ID0gZ2V0UG9pbnQoY29udGV4dC5ldmVudHMsIHJhbmdlWzJdKVxuICAgIGNvbnN0IHJlbGF0ZWRFbmQgPSBnZXRQb2ludChjb250ZXh0LmV2ZW50cywgcmFuZ2VbM10pXG4gICAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cbiAgICBjb25zdCB2YWx1ZVRva2VuID0ge1xuICAgICAgdHlwZTogdmFsdWVOYW1lLFxuICAgICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIHJlbGF0ZWRTdGFydCksXG4gICAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIHJlbGF0ZWRFbmQpXG4gICAgfVxuICAgIG1hcC5hZGQocmFuZ2VbMl0sIDAsIFtbJ2VudGVyJywgdmFsdWVUb2tlbiwgY29udGV4dF1dKVxuICAgIGFzc2VydChyYW5nZVszXSAhPT0gMClcblxuICAgIGlmIChyb3dLaW5kICE9PSAyKSB7XG4gICAgICAvLyBGaXggcG9zaXRpb25hbCBpbmZvIG9uIHJlbWFpbmluZyBldmVudHNcbiAgICAgIGNvbnN0IHN0YXJ0ID0gY29udGV4dC5ldmVudHNbcmFuZ2VbMl1dXG4gICAgICBjb25zdCBlbmQgPSBjb250ZXh0LmV2ZW50c1tyYW5nZVszXV1cbiAgICAgIHN0YXJ0WzFdLmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIGVuZFsxXS5lbmQpXG4gICAgICBzdGFydFsxXS50eXBlID0gdHlwZXMuY2h1bmtUZXh0XG4gICAgICBzdGFydFsxXS5jb250ZW50VHlwZSA9IGNvbnN0YW50cy5jb250ZW50VHlwZVRleHRcblxuICAgICAgLy8gUmVtb3ZlIGlmIG5lZWRlZC5cbiAgICAgIGlmIChyYW5nZVszXSA+IHJhbmdlWzJdICsgMSkge1xuICAgICAgICBjb25zdCBhID0gcmFuZ2VbMl0gKyAxXG4gICAgICAgIGNvbnN0IGIgPSByYW5nZVszXSAtIHJhbmdlWzJdIC0gMVxuICAgICAgICBtYXAuYWRkKGEsIGIsIFtdKVxuICAgICAgfVxuICAgIH1cblxuICAgIG1hcC5hZGQocmFuZ2VbM10gKyAxLCAwLCBbWydleGl0JywgdmFsdWVUb2tlbiwgY29udGV4dF1dKVxuICB9XG5cbiAgLy8gSW5zZXJ0IGFuIGV4aXQgZm9yIHRoZSBsYXN0IGNlbGwsIGlmIGF0IHRoZSByb3cgZW5kLlxuICAvL1xuICAvLyBgYGBtYXJrZG93blxuICAvLyA+IHwgfCBhYSB8IGJiIHwgY2MgfFxuICAvLyAgICAgICAgICAgICAgICAgICAgXi0tIGV4aXRcbiAgLy8gICAgICAgICAgICAgICBeXl5eXl4tLSB0aGlzIGNlbGwgKHRoZSBsYXN0IG9uZSBjb250YWlucyB0d28g4oCcYmV0d2VlbuKAnSBwYXJ0cylcbiAgLy8gYGBgXG4gIGlmIChyb3dFbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIHByZXZpb3VzQ2VsbC5lbmQgPSBPYmplY3QuYXNzaWduKHt9LCBnZXRQb2ludChjb250ZXh0LmV2ZW50cywgcm93RW5kKSlcbiAgICBtYXAuYWRkKHJvd0VuZCwgMCwgW1snZXhpdCcsIHByZXZpb3VzQ2VsbCwgY29udGV4dF1dKVxuICAgIHByZXZpb3VzQ2VsbCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgcmV0dXJuIHByZXZpb3VzQ2VsbFxufVxuXG4vKipcbiAqIEdlbmVyYXRlIHRhYmxlIGVuZCAoYW5kIHRhYmxlIGJvZHkgZW5kKS5cbiAqXG4gKiBAcGFyYW0ge0VkaXRNYXB9IG1hcFxuICogQHBhcmFtIHtUb2tlbml6ZUNvbnRleHR9IGNvbnRleHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtUb2tlbn0gdGFibGVcbiAqIEBwYXJhbSB7VG9rZW4gfCB1bmRlZmluZWR9IHRhYmxlQm9keVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuZnVuY3Rpb24gZmx1c2hUYWJsZUVuZChtYXAsIGNvbnRleHQsIGluZGV4LCB0YWJsZSwgdGFibGVCb2R5KSB7XG4gIC8qKiBAdHlwZSB7QXJyYXk8RXZlbnQ+fSAqL1xuICBjb25zdCBleGl0cyA9IFtdXG4gIGNvbnN0IHJlbGF0ZWQgPSBnZXRQb2ludChjb250ZXh0LmV2ZW50cywgaW5kZXgpXG5cbiAgaWYgKHRhYmxlQm9keSkge1xuICAgIHRhYmxlQm9keS5lbmQgPSBPYmplY3QuYXNzaWduKHt9LCByZWxhdGVkKVxuICAgIGV4aXRzLnB1c2goWydleGl0JywgdGFibGVCb2R5LCBjb250ZXh0XSlcbiAgfVxuXG4gIHRhYmxlLmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIHJlbGF0ZWQpXG4gIGV4aXRzLnB1c2goWydleGl0JywgdGFibGUsIGNvbnRleHRdKVxuXG4gIG1hcC5hZGQoaW5kZXggKyAxLCAwLCBleGl0cylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEV2ZW50Pn0gZXZlbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm5zIHtyZWFkb25seSBQb2ludH1cbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnQoZXZlbnRzLCBpbmRleCkge1xuICBjb25zdCBldmVudCA9IGV2ZW50c1tpbmRleF1cbiAgY29uc3Qgc2lkZSA9IGV2ZW50WzBdID09PSAnZW50ZXInID8gJ3N0YXJ0JyA6ICdlbmQnXG4gIHJldHVybiBldmVudFsxXVtzaWRlXVxufVxuIl0sIm5hbWVzIjpbIm9rIiwiYXNzZXJ0IiwiZmFjdG9yeVNwYWNlIiwibWFya2Rvd25MaW5lRW5kaW5nIiwibWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZSIsIm1hcmtkb3duU3BhY2UiLCJjb2RlcyIsImNvbnN0YW50cyIsInR5cGVzIiwiRWRpdE1hcCIsImdmbVRhYmxlQWxpZ24iLCJnZm1UYWJsZSIsImZsb3ciLCJudWxsIiwidG9rZW5pemUiLCJ0b2tlbml6ZVRhYmxlIiwicmVzb2x2ZUFsbCIsInJlc29sdmVUYWJsZSIsImVmZmVjdHMiLCJub2siLCJzZWxmIiwic2l6ZSIsInNpemVCIiwic2VlbiIsInN0YXJ0IiwiY29kZSIsImluZGV4IiwiZXZlbnRzIiwibGVuZ3RoIiwidHlwZSIsImxpbmVFbmRpbmciLCJsaW5lUHJlZml4IiwidGFpbCIsIm5leHQiLCJib2R5Um93U3RhcnQiLCJoZWFkUm93QmVmb3JlIiwicGFyc2VyIiwibGF6eSIsIm5vdyIsImxpbmUiLCJlbnRlciIsImhlYWRSb3dTdGFydCIsInZlcnRpY2FsQmFyIiwiaGVhZFJvd0JyZWFrIiwiZW9mIiwiaW50ZXJydXB0IiwiZXhpdCIsImNvbnN1bWUiLCJoZWFkRGVsaW1pdGVyU3RhcnQiLCJ3aGl0ZXNwYWNlIiwiZGF0YSIsImhlYWRSb3dEYXRhIiwiYmFja3NsYXNoIiwiaGVhZFJvd0VzY2FwZSIsImNvbnN0cnVjdHMiLCJkaXNhYmxlIiwiaGVhZERlbGltaXRlckJlZm9yZSIsImluY2x1ZGVzIiwidW5kZWZpbmVkIiwidGFiU2l6ZSIsImRhc2giLCJjb2xvbiIsImhlYWREZWxpbWl0ZXJWYWx1ZUJlZm9yZSIsImhlYWREZWxpbWl0ZXJDZWxsQmVmb3JlIiwiaGVhZERlbGltaXRlck5vayIsImhlYWREZWxpbWl0ZXJMZWZ0QWxpZ25tZW50QWZ0ZXIiLCJoZWFkRGVsaW1pdGVyQ2VsbEFmdGVyIiwiaGVhZERlbGltaXRlckZpbGxlciIsImhlYWREZWxpbWl0ZXJSaWdodEFsaWdubWVudEFmdGVyIiwiYm9keVJvd0JyZWFrIiwiYm9keVJvd0RhdGEiLCJib2R5Um93RXNjYXBlIiwiY29udGV4dCIsImluRmlyc3RDZWxsQXdhaXRpbmdQaXBlIiwicm93S2luZCIsImxhc3RDZWxsIiwiY2VsbCIsImFmdGVySGVhZEF3YWl0aW5nRmlyc3RCb2R5Um93IiwibGFzdFRhYmxlRW5kIiwiY3VycmVudFRhYmxlIiwiY3VycmVudEJvZHkiLCJjdXJyZW50Q2VsbCIsIm1hcCIsImV2ZW50IiwidG9rZW4iLCJmbHVzaFRhYmxlRW5kIiwiT2JqZWN0IiwiYXNzaWduIiwiZW5kIiwiYWRkIiwiZmx1c2hDZWxsIiwiX2FsaWduIiwicmFuZ2UiLCJyb3dFbmQiLCJwcmV2aW91c0NlbGwiLCJncm91cE5hbWUiLCJ2YWx1ZU5hbWUiLCJnZXRQb2ludCIsInJlbGF0ZWRTdGFydCIsInJlbGF0ZWRFbmQiLCJ2YWx1ZVRva2VuIiwiY2h1bmtUZXh0IiwiY29udGVudFR5cGUiLCJjb250ZW50VHlwZVRleHQiLCJhIiwiYiIsInRhYmxlIiwidGFibGVCb2R5IiwiZXhpdHMiLCJyZWxhdGVkIiwicHVzaCIsInNpZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/micromark-extension-gfm-table/dev/lib/syntax.js\n");

/***/ })

};
;